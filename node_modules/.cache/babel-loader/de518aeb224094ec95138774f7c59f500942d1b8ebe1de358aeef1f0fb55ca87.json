{"ast":null,"code":"var __typeError = msg => {\n  throw TypeError(msg);\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nvar __privateMethod = (obj, member, method) => (__accessCheck(obj, member, \"access private method\"), method);\n\n// src/exceptions/no-client-id-provided.exception.ts\nvar NoClientIdProvidedException = class extends Error {\n  constructor() {\n    super(...arguments);\n    this.status = 500;\n    this.name = \"NoClientIdProvidedException\";\n    this.message = `Missing Client ID. Pass it to the constructor (createClient(\"client_01HXRMBQ9BJ3E7QSTQ9X2PHVB7\"))`;\n  }\n};\n\n// src/utils/is-redirect-callback.ts\nfunction isRedirectCallback(redirectUri, searchParams) {\n  const hasCode = searchParams.has(\"code\");\n  if (!hasCode) return false;\n  const {\n    pathname: currentPathName\n  } = window.location;\n  const redirectPathname = new URL(redirectUri).pathname;\n  return currentPathName === redirectPathname || currentPathName === `${redirectPathname}/`;\n}\n\n// src/utils/memory-storage.ts\nfunction createMemoryStorage() {\n  let _store = {};\n  function setItem(key, value) {\n    _store[key] = value;\n  }\n  function getItem(key) {\n    return _store[key];\n  }\n  function removeItem(key) {\n    delete _store[key];\n  }\n  function reset() {\n    _store = {};\n  }\n  return {\n    setItem,\n    getItem,\n    removeItem,\n    reset\n  };\n}\nvar memoryStorage = createMemoryStorage();\n\n// src/utils/pkce.ts\nasync function createPkceChallenge() {\n  const codeVerifier = createCodeVerifier();\n  const codeChallenge = await createCodeChallenge(codeVerifier);\n  return {\n    codeVerifier,\n    codeChallenge\n  };\n}\nfunction createCodeVerifier() {\n  const randomBytes = crypto.getRandomValues(new Uint32Array(96));\n  return base64urlEncode(randomBytes);\n}\nasync function createCodeChallenge(codeVerifier) {\n  const hashed = await sha256(codeVerifier);\n  return base64urlEncode(hashed);\n}\nfunction base64urlEncode(buffer) {\n  return btoa(Array.from(new Uint8Array(buffer), b => String.fromCharCode(b)).join(\"\")).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n}\nfunction sha256(plain) {\n  const encoder = new TextEncoder();\n  const data = encoder.encode(plain);\n  return crypto.subtle.digest(\"SHA-256\", data);\n}\n\n// src/utils/jwt.ts\nfunction decodeBase64Url(input) {\n  const base64 = input.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  const padding = \"=\".repeat((4 - base64.length % 4) % 4);\n  return atob(base64 + padding);\n}\nfunction decodeJwt(token) {\n  const parts = token.split(\".\");\n  if (parts.length !== 3) {\n    throw new Error(\"Invalid JWT format\");\n  }\n  try {\n    const header = JSON.parse(decodeBase64Url(parts[0]));\n    const payload = JSON.parse(decodeBase64Url(parts[1]));\n    return {\n      header,\n      payload\n    };\n  } catch (error) {\n    throw new Error(`Failed to decode JWT: ${error instanceof Error ? error.message : String(error)}`);\n  }\n}\n\n// src/utils/storage-keys.ts\nvar storageKeys = {\n  codeVerifier: \"workos:code-verifier\",\n  user: \"workos:user\",\n  accessToken: \"workos:access-token\",\n  refreshToken: \"workos:refresh-token\",\n  expiresAt: \"workos:expires-at\"\n};\n\n// src/utils/session-data.ts\nfunction getClaims(accessToken) {\n  return decodeJwt(accessToken).payload;\n}\nfunction setSessionData(data, {\n  devMode = false\n} = {}) {\n  const {\n    user,\n    accessToken,\n    refreshToken\n  } = data;\n  memoryStorage.setItem(storageKeys.user, user);\n  memoryStorage.setItem(storageKeys.accessToken, accessToken);\n  (devMode ? window.localStorage : memoryStorage).setItem(storageKeys.refreshToken, refreshToken);\n  const {\n    exp,\n    iat\n  } = getClaims(accessToken);\n  const expiresIn = exp - iat;\n  const expiresAt = Date.now() + expiresIn * 1e3;\n  memoryStorage.setItem(storageKeys.expiresAt, expiresAt);\n}\nfunction removeSessionData({\n  devMode = false\n} = {}) {\n  memoryStorage.removeItem(storageKeys.user);\n  memoryStorage.removeItem(storageKeys.accessToken);\n  (devMode ? window.localStorage : memoryStorage).removeItem(storageKeys.refreshToken);\n}\nfunction getRefreshToken({\n  devMode = false\n} = {}) {\n  return (devMode ? window.localStorage : memoryStorage).getItem(storageKeys.refreshToken);\n}\n\n// src/utils/to-query-string.ts\nfunction toQueryString(options) {\n  const searchParams = new URLSearchParams();\n  const keys = Object.keys(options).sort();\n  for (const key of keys) {\n    const value = options[key];\n    if (value) {\n      searchParams.append(key, value);\n    }\n  }\n  return searchParams.toString();\n}\n\n// src/errors.ts\nvar AuthKitError = class extends Error {};\nvar RefreshError = class extends AuthKitError {};\nvar CodeExchangeError = class extends AuthKitError {};\nvar LoginRequiredError = class extends AuthKitError {\n  constructor() {\n    super(...arguments);\n    this.message = \"No access token available\";\n  }\n};\n\n// src/vendor/browser-tabs-lock/processLock.ts\nvar ProcessLocking = class _ProcessLocking {\n  constructor() {\n    this.locked = /* @__PURE__ */new Map();\n    this.addToLocked = (key, toAdd) => {\n      let callbacks = this.locked.get(key);\n      if (callbacks === void 0) {\n        if (toAdd === void 0) {\n          this.locked.set(key, []);\n        } else {\n          this.locked.set(key, [toAdd]);\n        }\n      } else {\n        if (toAdd !== void 0) {\n          callbacks.unshift(toAdd);\n          this.locked.set(key, callbacks);\n        }\n      }\n    };\n    this.isLocked = key => {\n      return this.locked.has(key);\n    };\n    this.lock = key => {\n      return new Promise((resolve, reject) => {\n        if (this.isLocked(key)) {\n          this.addToLocked(key, resolve);\n        } else {\n          this.addToLocked(key);\n          resolve();\n        }\n      });\n    };\n    this.unlock = key => {\n      let callbacks = this.locked.get(key);\n      if (callbacks === void 0 || callbacks.length === 0) {\n        this.locked.delete(key);\n        return;\n      }\n      let toCall = callbacks.pop();\n      this.locked.set(key, callbacks);\n      if (toCall !== void 0) {\n        setTimeout(toCall, 0);\n      }\n    };\n  }\n  static getInstance() {\n    if (_ProcessLocking.instance === void 0) {\n      _ProcessLocking.instance = new _ProcessLocking();\n    }\n    return _ProcessLocking.instance;\n  }\n};\nfunction getLock() {\n  return ProcessLocking.getInstance();\n}\n\n// src/vendor/browser-tabs-lock/index.ts\nvar LOCK_STORAGE_KEY = \"browser-tabs-lock-key\";\nvar DEFAULT_STORAGE_HANDLER = {\n  key: async index => {\n    throw new Error(\"Unsupported\");\n  },\n  getItem: async key => {\n    throw new Error(\"Unsupported\");\n  },\n  clear: async () => {\n    return window.localStorage.clear();\n  },\n  removeItem: async key => {\n    throw new Error(\"Unsupported\");\n  },\n  setItem: async (key, value) => {\n    throw new Error(\"Unsupported\");\n  },\n  keySync: index => {\n    return window.localStorage.key(index);\n  },\n  getItemSync: key => {\n    return window.localStorage.getItem(key);\n  },\n  clearSync: () => {\n    return window.localStorage.clear();\n  },\n  removeItemSync: key => {\n    return window.localStorage.removeItem(key);\n  },\n  setItemSync: (key, value) => {\n    return window.localStorage.setItem(key, value);\n  }\n};\nfunction delay(milliseconds) {\n  return new Promise(resolve => setTimeout(resolve, milliseconds));\n}\nfunction generateRandomString(length) {\n  const CHARS = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz\";\n  let randomstring = \"\";\n  for (let i = 0; i < length; i++) {\n    const INDEX = Math.floor(Math.random() * CHARS.length);\n    randomstring += CHARS[INDEX];\n  }\n  return randomstring;\n}\nfunction getLockId() {\n  return Date.now().toString() + generateRandomString(15);\n}\nvar _SuperTokensLock = class _SuperTokensLock {\n  constructor(storageHandler) {\n    this.acquiredIatSet = /* @__PURE__ */new Set();\n    this.storageHandler = void 0;\n    this.id = getLockId();\n    this.acquireLock = this.acquireLock.bind(this);\n    this.releaseLock = this.releaseLock.bind(this);\n    this.releaseLock__private__ = this.releaseLock__private__.bind(this);\n    this.waitForSomethingToChange = this.waitForSomethingToChange.bind(this);\n    this.refreshLockWhileAcquired = this.refreshLockWhileAcquired.bind(this);\n    this.storageHandler = storageHandler;\n    if (_SuperTokensLock.waiters === void 0) {\n      _SuperTokensLock.waiters = [];\n    }\n  }\n  /**\n   * @async\n   * @memberOf Lock\n   * @function acquireLock\n   * @param {string} lockKey - Key for which the lock is being acquired\n   * @param {number} [timeout=5000] - Maximum time for which the function will wait to acquire the lock\n   * @returns {Promise<boolean>}\n   * @description Will return true if lock is being acquired, else false.\n   *              Also the lock can be acquired for maximum 10 secs\n   */\n  async acquireLock(lockKey, timeout = 5e3) {\n    let iat = Date.now() + generateRandomString(4);\n    const MAX_TIME = Date.now() + timeout;\n    const STORAGE_KEY = `${LOCK_STORAGE_KEY}-${lockKey}`;\n    const STORAGE = this.storageHandler === void 0 ? DEFAULT_STORAGE_HANDLER : this.storageHandler;\n    while (Date.now() < MAX_TIME) {\n      await delay(30);\n      let lockObj = STORAGE.getItemSync(STORAGE_KEY);\n      if (lockObj === null) {\n        const TIMEOUT_KEY = `${this.id}-${lockKey}-${iat}`;\n        await delay(Math.floor(Math.random() * 25));\n        STORAGE.setItemSync(STORAGE_KEY, JSON.stringify({\n          id: this.id,\n          iat,\n          timeoutKey: TIMEOUT_KEY,\n          timeAcquired: Date.now(),\n          timeRefreshed: Date.now()\n        }));\n        await delay(30);\n        let lockObjPostDelay = STORAGE.getItemSync(STORAGE_KEY);\n        if (lockObjPostDelay !== null) {\n          let parsedLockObjPostDelay = JSON.parse(lockObjPostDelay);\n          if (parsedLockObjPostDelay.id === this.id && parsedLockObjPostDelay.iat === iat) {\n            this.acquiredIatSet.add(iat);\n            this.refreshLockWhileAcquired(STORAGE_KEY, iat);\n            return true;\n          }\n        }\n      } else {\n        _SuperTokensLock.lockCorrector(this.storageHandler === void 0 ? DEFAULT_STORAGE_HANDLER : this.storageHandler);\n        await this.waitForSomethingToChange(MAX_TIME);\n      }\n      iat = Date.now() + generateRandomString(4);\n    }\n    return false;\n  }\n  async refreshLockWhileAcquired(storageKey, iat) {\n    setTimeout(async () => {\n      await getLock().lock(iat);\n      if (!this.acquiredIatSet.has(iat)) {\n        getLock().unlock(iat);\n        return;\n      }\n      const STORAGE = this.storageHandler === void 0 ? DEFAULT_STORAGE_HANDLER : this.storageHandler;\n      let lockObj = STORAGE.getItemSync(storageKey);\n      if (lockObj !== null) {\n        let parsedLockObj = JSON.parse(lockObj);\n        parsedLockObj.timeRefreshed = Date.now();\n        STORAGE.setItemSync(storageKey, JSON.stringify(parsedLockObj));\n        getLock().unlock(iat);\n      } else {\n        getLock().unlock(iat);\n        return;\n      }\n      this.refreshLockWhileAcquired(storageKey, iat);\n    }, 1e3);\n  }\n  async waitForSomethingToChange(MAX_TIME) {\n    await new Promise(resolve => {\n      let resolvedCalled = false;\n      let startedAt = Date.now();\n      const MIN_TIME_TO_WAIT = 50;\n      let removedListeners = false;\n      function stopWaiting() {\n        if (!removedListeners) {\n          window.removeEventListener(\"storage\", stopWaiting);\n          _SuperTokensLock.removeFromWaiting(stopWaiting);\n          clearTimeout(timeOutId);\n          removedListeners = true;\n        }\n        if (!resolvedCalled) {\n          resolvedCalled = true;\n          let timeToWait = MIN_TIME_TO_WAIT - (Date.now() - startedAt);\n          if (timeToWait > 0) {\n            setTimeout(resolve, timeToWait);\n          } else {\n            resolve(null);\n          }\n        }\n      }\n      window.addEventListener(\"storage\", stopWaiting);\n      _SuperTokensLock.addToWaiting(stopWaiting);\n      let timeOutId = setTimeout(stopWaiting, Math.max(0, MAX_TIME - Date.now()));\n    });\n  }\n  static addToWaiting(func) {\n    this.removeFromWaiting(func);\n    if (_SuperTokensLock.waiters === void 0) {\n      return;\n    }\n    _SuperTokensLock.waiters.push(func);\n  }\n  static removeFromWaiting(func) {\n    if (_SuperTokensLock.waiters === void 0) {\n      return;\n    }\n    _SuperTokensLock.waiters = _SuperTokensLock.waiters.filter(i => i !== func);\n  }\n  static notifyWaiters() {\n    if (_SuperTokensLock.waiters === void 0) {\n      return;\n    }\n    let waiters = [..._SuperTokensLock.waiters];\n    waiters.forEach(i => i());\n  }\n  /**\n   * @function releaseLock\n   * @memberOf Lock\n   * @param {string} lockKey - Key for which lock is being released\n   * @returns {void}\n   * @description Release a lock.\n   */\n  async releaseLock(lockKey) {\n    return await this.releaseLock__private__(lockKey);\n  }\n  /**\n   * @function releaseLock\n   * @memberOf Lock\n   * @param {string} lockKey - Key for which lock is being released\n   * @returns {void}\n   * @description Release a lock.\n   */\n  async releaseLock__private__(lockKey) {\n    const STORAGE = this.storageHandler === void 0 ? DEFAULT_STORAGE_HANDLER : this.storageHandler;\n    const STORAGE_KEY = `${LOCK_STORAGE_KEY}-${lockKey}`;\n    let lockObj = STORAGE.getItemSync(STORAGE_KEY);\n    if (lockObj === null) {\n      return;\n    }\n    let parsedlockObj = JSON.parse(lockObj);\n    if (parsedlockObj.id === this.id) {\n      await getLock().lock(parsedlockObj.iat);\n      this.acquiredIatSet.delete(parsedlockObj.iat);\n      STORAGE.removeItemSync(STORAGE_KEY);\n      getLock().unlock(parsedlockObj.iat);\n      _SuperTokensLock.notifyWaiters();\n    }\n  }\n  /**\n   * @function lockCorrector\n   * @returns {void}\n   * @description If a lock is acquired by a tab and the tab is closed before the lock is\n   *              released, this function will release those locks\n   */\n  static lockCorrector(storageHandler) {\n    const MIN_ALLOWED_TIME = Date.now() - 5e3;\n    const STORAGE = storageHandler;\n    const KEYS = [];\n    let currIndex = 0;\n    while (true) {\n      let key = STORAGE.keySync(currIndex);\n      if (key === null) {\n        break;\n      }\n      KEYS.push(key);\n      currIndex++;\n    }\n    let notifyWaiters = false;\n    for (let i = 0; i < KEYS.length; i++) {\n      const LOCK_KEY = KEYS[i];\n      if (LOCK_KEY.includes(LOCK_STORAGE_KEY)) {\n        let lockObj = STORAGE.getItemSync(LOCK_KEY);\n        if (lockObj !== null) {\n          let parsedlockObj = JSON.parse(lockObj);\n          if (parsedlockObj.timeRefreshed === void 0 && parsedlockObj.timeAcquired < MIN_ALLOWED_TIME || parsedlockObj.timeRefreshed !== void 0 && parsedlockObj.timeRefreshed < MIN_ALLOWED_TIME) {\n            STORAGE.removeItemSync(LOCK_KEY);\n            notifyWaiters = true;\n          }\n        }\n      }\n    }\n    if (notifyWaiters) {\n      _SuperTokensLock.notifyWaiters();\n    }\n  }\n};\n_SuperTokensLock.waiters = void 0;\nvar SuperTokensLock = _SuperTokensLock;\n\n// src/utils/locking.ts\nvar DEFAULT_LOCK_TIMEOUT_MS = 1e4;\nfunction withLock(lockName, callback, {\n  timeout = DEFAULT_LOCK_TIMEOUT_MS\n} = {}) {\n  if (!lockName) {\n    throw new TypeError(\"lockName is required and must be a non-empty string.\");\n  }\n  return \"locks\" in navigator ? withNativeLock(lockName, callback, timeout) : withVendorLock(lockName, callback, timeout);\n}\nasync function withNativeLock(lockName, callback, timeout) {\n  try {\n    return await navigator.locks.request(lockName, {\n      signal: AbortSignal.timeout(timeout)\n    }, callback);\n  } catch (error) {\n    if (error instanceof DOMException) {\n      switch (error.name) {\n        case \"AbortError\":\n          throw new LockError(\"AcquisitionTimeoutError\", lockName, \"Native\");\n        case \"InvalidStateError\":\n        case \"NotSupportedError\":\n        case \"SecurityError\":\n      }\n    }\n    throw error;\n  }\n}\nasync function withVendorLock(lockName, callback, timeout) {\n  const lock = new SuperTokensLock();\n  try {\n    if (await lock.acquireLock(lockName, timeout)) {\n      return await callback();\n    } else {\n      throw new LockError(\"AcquisitionTimeoutError\", lockName, \"Vendor\");\n    }\n  } finally {\n    await lock.releaseLock(lockName);\n  }\n}\nvar LockError = class extends Error {\n  constructor(name, lockName, type) {\n    super(`Lock acquisition timed out for \"${lockName}\" (${type})`);\n    this.name = name;\n    this.lockName = lockName;\n  }\n};\n\n// src/serializers/user.serializer.ts\nvar deserializeUser = user => ({\n  object: user.object,\n  id: user.id,\n  email: user.email,\n  emailVerified: user.email_verified,\n  firstName: user.first_name,\n  profilePictureUrl: user.profile_picture_url,\n  lastName: user.last_name,\n  lastSignInAt: user.last_sign_in_at,\n  externalId: user.external_id,\n  createdAt: user.created_at,\n  updatedAt: user.updated_at\n});\n\n// src/serializers/authentication-response.serializer.ts\nvar deserializeAuthenticationResponse = authenticationResponse => {\n  const {\n    user,\n    organization_id,\n    access_token,\n    refresh_token,\n    impersonator,\n    ...rest\n  } = authenticationResponse;\n  return {\n    user: deserializeUser(user),\n    organizationId: organization_id,\n    accessToken: access_token,\n    refreshToken: refresh_token,\n    impersonator,\n    ...rest\n  };\n};\n\n// src/http-client.ts\nvar DEFAULT_HOSTNAME = \"api.workos.com\";\nvar _baseUrl, _clientId, _HttpClient_instances, post_fn;\nvar HttpClient = class {\n  constructor({\n    clientId,\n    hostname = DEFAULT_HOSTNAME,\n    port,\n    https = true\n  }) {\n    __privateAdd(this, _HttpClient_instances);\n    __privateAdd(this, _baseUrl);\n    __privateAdd(this, _clientId);\n    __privateSet(this, _baseUrl, `${https ? \"https\" : \"http\"}://${hostname}${port ? `:${port}` : \"\"}`);\n    __privateSet(this, _clientId, clientId);\n  }\n  async authenticateWithRefreshToken({\n    refreshToken,\n    organizationId,\n    useCookie\n  }) {\n    const response = await __privateMethod(this, _HttpClient_instances, post_fn).call(this, \"/user_management/authenticate\", {\n      useCookie,\n      body: {\n        client_id: __privateGet(this, _clientId),\n        grant_type: \"refresh_token\",\n        ...(!useCookie && {\n          refresh_token: refreshToken\n        }),\n        organization_id: organizationId\n      }\n    });\n    if (response.ok) {\n      const data = await response.json();\n      return deserializeAuthenticationResponse(data);\n    } else {\n      const error = await response.json();\n      throw new RefreshError(error.error_description);\n    }\n  }\n  async authenticateWithCode({\n    code,\n    codeVerifier,\n    useCookie\n  }) {\n    const response = await __privateMethod(this, _HttpClient_instances, post_fn).call(this, \"/user_management/authenticate\", {\n      useCookie,\n      body: {\n        code,\n        client_id: __privateGet(this, _clientId),\n        grant_type: \"authorization_code\",\n        code_verifier: codeVerifier\n      }\n    });\n    if (response.ok) {\n      const data = await response.json();\n      return deserializeAuthenticationResponse(data);\n    }\n    const error = await response.json();\n    throw new CodeExchangeError(error.error_description);\n  }\n  getAuthorizationUrl({\n    connectionId,\n    context,\n    domainHint,\n    loginHint,\n    organizationId,\n    provider = \"authkit\",\n    redirectUri,\n    state,\n    screenHint,\n    passwordResetToken,\n    invitationToken,\n    codeChallenge,\n    codeChallengeMethod\n  }) {\n    if (!provider && !connectionId && !organizationId) {\n      throw new TypeError(`Incomplete arguments. Need to specify either a 'connectionId', 'organizationId', or 'provider'.`);\n    }\n    if (provider !== \"authkit\" && screenHint) {\n      throw new TypeError(`'screenHint' is only supported for 'authkit' provider`);\n    }\n    if (context) {\n      console.warn(`\\`context\\` is deprecated. We previously required initiate login endpoints to return the\n\\`context\\` query parameter when getting the authorization URL. This is no longer necessary.`);\n    }\n    const query = toQueryString({\n      connection_id: connectionId,\n      organization_id: organizationId,\n      domain_hint: domainHint,\n      login_hint: loginHint,\n      provider,\n      client_id: __privateGet(this, _clientId),\n      redirect_uri: redirectUri,\n      response_type: \"code\",\n      state,\n      screen_hint: screenHint,\n      invitation_token: invitationToken,\n      password_reset_token: passwordResetToken,\n      code_challenge: codeChallenge,\n      code_challenge_method: codeChallengeMethod\n    });\n    return `${__privateGet(this, _baseUrl)}/user_management/authorize?${query}`;\n  }\n  getLogoutUrl({\n    sessionId,\n    returnTo\n  }) {\n    const url = new URL(\"/user_management/sessions/logout\", __privateGet(this, _baseUrl));\n    url.searchParams.set(\"session_id\", sessionId);\n    if (returnTo) {\n      url.searchParams.set(\"return_to\", returnTo);\n    }\n    return url;\n  }\n};\n_baseUrl = new WeakMap();\n_clientId = new WeakMap();\n_HttpClient_instances = new WeakSet();\npost_fn = function (path, {\n  body,\n  useCookie\n}) {\n  return fetch(new URL(path, __privateGet(this, _baseUrl)), {\n    method: \"POST\",\n    ...(useCookie && {\n      credentials: \"include\"\n    }),\n    headers: {\n      Accept: \"application/json, text/plain, */*\",\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify(body)\n  });\n};\n\n// src/create-client.ts\nvar ORGANIZATION_ID_SESSION_STORAGE_KEY = \"workos_organization_id\";\nvar REFRESH_LOCK_NAME = \"WORKOS_REFRESH_SESSION\";\nvar _state, _refreshTimer, _httpClient, _redirectUri, _devMode, _onBeforeAutoRefresh, _onRedirectCallback, _onRefreshCallback, _onRefreshFailure, _refreshBufferInterval, _Client_instances, handleCallback_fn, scheduleAutomaticRefresh_fn, refreshSession_fn, doRefresh_fn, shouldRefresh_fn, getAuthorizationUrl_fn, getAccessToken_fn, useCookie_get, onRefresh_fn;\nvar Client = class {\n  constructor(clientId, {\n    apiHostname: hostname,\n    https,\n    port,\n    redirectUri = window.origin,\n    devMode = location.hostname === \"localhost\" || location.hostname === \"127.0.0.1\",\n    // refresh if this is true\n    onBeforeAutoRefresh = () => {\n      return !document.hidden;\n    },\n    onRedirectCallback = _ => {},\n    onRefresh,\n    onRefreshFailure,\n    refreshBufferInterval = 10\n  } = {}) {\n    __privateAdd(this, _Client_instances);\n    __privateAdd(this, _state);\n    __privateAdd(this, _refreshTimer);\n    __privateAdd(this, _httpClient);\n    __privateAdd(this, _redirectUri);\n    __privateAdd(this, _devMode);\n    __privateAdd(this, _onBeforeAutoRefresh);\n    __privateAdd(this, _onRedirectCallback);\n    __privateAdd(this, _onRefreshCallback);\n    __privateAdd(this, _onRefreshFailure);\n    __privateAdd(this, _refreshBufferInterval);\n    if (!clientId) {\n      throw new NoClientIdProvidedException();\n    }\n    __privateSet(this, _httpClient, new HttpClient({\n      clientId,\n      hostname,\n      port,\n      https\n    }));\n    __privateSet(this, _devMode, devMode);\n    __privateSet(this, _redirectUri, redirectUri);\n    __privateSet(this, _state, {\n      tag: \"INITIAL\"\n    });\n    __privateSet(this, _onBeforeAutoRefresh, onBeforeAutoRefresh);\n    __privateSet(this, _onRedirectCallback, onRedirectCallback);\n    __privateSet(this, _onRefreshCallback, onRefresh);\n    __privateSet(this, _onRefreshFailure, onRefreshFailure);\n    __privateSet(this, _refreshBufferInterval, refreshBufferInterval);\n  }\n  async initialize() {\n    if (__privateGet(this, _state).tag !== \"INITIAL\") {\n      return;\n    }\n    const searchParams = new URLSearchParams(window.location.search);\n    if (isRedirectCallback(__privateGet(this, _redirectUri), searchParams)) {\n      await __privateMethod(this, _Client_instances, handleCallback_fn).call(this);\n    } else if (document.cookie.includes(\"workos-has-session=\") || getRefreshToken({\n      devMode: __privateGet(this, _devMode)\n    })) {\n      try {\n        await __privateMethod(this, _Client_instances, refreshSession_fn).call(this);\n        __privateMethod(this, _Client_instances, scheduleAutomaticRefresh_fn).call(this);\n      } catch {}\n    }\n  }\n  async getSignInUrl(opts = {}) {\n    const url = await __privateMethod(this, _Client_instances, getAuthorizationUrl_fn).call(this, {\n      ...opts,\n      type: \"sign-in\"\n    });\n    return url;\n  }\n  async getSignUpUrl(opts = {}) {\n    const url = await __privateMethod(this, _Client_instances, getAuthorizationUrl_fn).call(this, {\n      ...opts,\n      type: \"sign-up\"\n    });\n    return url;\n  }\n  async signIn(opts = {}) {\n    const url = await __privateMethod(this, _Client_instances, getAuthorizationUrl_fn).call(this, {\n      ...opts,\n      type: \"sign-in\"\n    });\n    window.location.assign(url);\n  }\n  async signUp(opts = {}) {\n    const url = await __privateMethod(this, _Client_instances, getAuthorizationUrl_fn).call(this, {\n      ...opts,\n      type: \"sign-up\"\n    });\n    window.location.assign(url);\n  }\n  signOut(options = {\n    navigate: true\n  }) {\n    const navigate = options.navigate ?? true;\n    const accessToken = memoryStorage.getItem(storageKeys.accessToken);\n    if (typeof accessToken !== \"string\") return;\n    const {\n      sid: sessionId\n    } = getClaims(accessToken);\n    const url = __privateGet(this, _httpClient).getLogoutUrl({\n      sessionId,\n      returnTo: options?.returnTo\n    });\n    if (url) {\n      removeSessionData({\n        devMode: __privateGet(this, _devMode)\n      });\n      if (navigate) {\n        window.location.assign(url);\n      } else {\n        return new Promise(async resolve => {\n          fetch(url, {\n            mode: \"no-cors\",\n            credentials: \"include\"\n          }).catch(error => {\n            console.warn(\"AuthKit: Failed to send logout request\", error);\n          }).finally(resolve);\n        });\n      }\n    }\n  }\n  async getAccessToken(options) {\n    if (options?.forceRefresh || __privateMethod(this, _Client_instances, shouldRefresh_fn).call(this)) {\n      try {\n        await __privateMethod(this, _Client_instances, refreshSession_fn).call(this);\n      } catch (err) {\n        if (err instanceof RefreshError) {\n          throw new LoginRequiredError();\n        } else {\n          throw err;\n        }\n      }\n    }\n    const accessToken = __privateMethod(this, _Client_instances, getAccessToken_fn).call(this);\n    if (!accessToken) {\n      throw new LoginRequiredError();\n    }\n    return accessToken;\n  }\n  getUser() {\n    const user = memoryStorage.getItem(storageKeys.user);\n    return user ? user : null;\n  }\n  dispose() {\n    clearTimeout(__privateGet(this, _refreshTimer));\n    memoryStorage.reset();\n  }\n  /**\n   * Switches to the requested organization.\n   *\n   * Redirects to the hosted login page for the given organization if the\n   * switch is unsuccessful.\n   */\n  async switchToOrganization({\n    organizationId,\n    signInOpts = {}\n  }) {\n    try {\n      await __privateMethod(this, _Client_instances, refreshSession_fn).call(this, {\n        organizationId\n      });\n    } catch (error) {\n      if (error instanceof RefreshError) {\n        this.signIn({\n          ...signInOpts,\n          organizationId\n        });\n      } else {\n        throw error;\n      }\n    }\n  }\n};\n_state = new WeakMap();\n_refreshTimer = new WeakMap();\n_httpClient = new WeakMap();\n_redirectUri = new WeakMap();\n_devMode = new WeakMap();\n_onBeforeAutoRefresh = new WeakMap();\n_onRedirectCallback = new WeakMap();\n_onRefreshCallback = new WeakMap();\n_onRefreshFailure = new WeakMap();\n_refreshBufferInterval = new WeakMap();\n_Client_instances = new WeakSet();\nhandleCallback_fn = async function () {\n  if (__privateGet(this, _state).tag !== \"INITIAL\") {\n    return;\n  }\n  const url = new URL(window.location.href);\n  const code = url.searchParams.get(\"code\");\n  const stateParam = url.searchParams.get(\"state\");\n  const state = stateParam ? JSON.parse(stateParam) : void 0;\n  const codeVerifier = window.sessionStorage.getItem(storageKeys.codeVerifier);\n  if (code) {\n    if (codeVerifier) {\n      try {\n        __privateSet(this, _state, {\n          tag: \"AUTHENTICATING\",\n          response: __privateGet(this, _httpClient).authenticateWithCode({\n            code,\n            codeVerifier,\n            useCookie: __privateGet(this, _Client_instances, useCookie_get)\n          })\n        });\n        const authenticationResponse = await __privateGet(this, _state).response;\n        if (authenticationResponse) {\n          __privateSet(this, _state, {\n            tag: \"AUTHENTICATED\"\n          });\n          __privateMethod(this, _Client_instances, scheduleAutomaticRefresh_fn).call(this);\n          setSessionData(authenticationResponse, {\n            devMode: __privateGet(this, _devMode)\n          });\n          __privateMethod(this, _Client_instances, onRefresh_fn).call(this, authenticationResponse);\n          __privateGet(this, _onRedirectCallback).call(this, {\n            state,\n            ...authenticationResponse\n          });\n        }\n      } catch (error) {\n        __privateSet(this, _state, {\n          tag: \"ERROR\"\n        });\n        console.error(error);\n      }\n    } else {\n      __privateSet(this, _state, {\n        tag: \"ERROR\"\n      });\n      console.error(`Couldn't exchange code.\n\nAn authorization_code was supplied for a login which did not originate at the application. This could happen for various reasons:\n\n* This could have been an attempted Login CSRF attack. You were not affected.\n* The developer may not have configured a Login Initiation endpoint.`);\n    }\n  }\n  const cleanUrl = new URL(window.location.toString());\n  cleanUrl.search = \"\";\n  window.sessionStorage.removeItem(storageKeys.codeVerifier);\n  window.history.replaceState({}, \"\", cleanUrl);\n};\nscheduleAutomaticRefresh_fn = async function () {\n  __privateSet(this, _refreshTimer, setTimeout(() => {\n    if (__privateMethod(this, _Client_instances, shouldRefresh_fn).call(this) && __privateGet(this, _onBeforeAutoRefresh).call(this)) {\n      __privateMethod(this, _Client_instances, refreshSession_fn).call(this).catch(e => {\n        console.debug(e);\n      }).finally(() => __privateMethod(this, _Client_instances, scheduleAutomaticRefresh_fn).call(this));\n    } else {\n      __privateMethod(this, _Client_instances, scheduleAutomaticRefresh_fn).call(this);\n    }\n  }, 1e3));\n};\nrefreshSession_fn = async function ({\n  organizationId\n} = {}) {\n  if (__privateGet(this, _state).tag === \"AUTHENTICATING\") {\n    await __privateGet(this, _state).response;\n    return;\n  }\n  const beginningState = __privateGet(this, _state);\n  __privateSet(this, _state, {\n    tag: \"AUTHENTICATING\",\n    response: __privateMethod(this, _Client_instances, doRefresh_fn).call(this, {\n      organizationId,\n      beginningState\n    })\n  });\n  await __privateGet(this, _state).response;\n};\ndoRefresh_fn = async function ({\n  organizationId,\n  beginningState\n}) {\n  try {\n    return await withLock(REFRESH_LOCK_NAME, async () => {\n      if (organizationId) {\n        sessionStorage.setItem(ORGANIZATION_ID_SESSION_STORAGE_KEY, organizationId);\n      } else {\n        const accessToken = __privateMethod(this, _Client_instances, getAccessToken_fn).call(this);\n        if (accessToken) {\n          organizationId = getClaims(accessToken)?.org_id;\n        } else {\n          organizationId = sessionStorage.getItem(ORGANIZATION_ID_SESSION_STORAGE_KEY) ?? void 0;\n        }\n      }\n      const authenticationResponse = await __privateGet(this, _httpClient).authenticateWithRefreshToken({\n        refreshToken: getRefreshToken({\n          devMode: __privateGet(this, _devMode)\n        }),\n        organizationId,\n        useCookie: __privateGet(this, _Client_instances, useCookie_get)\n      });\n      __privateSet(this, _state, {\n        tag: \"AUTHENTICATED\"\n      });\n      setSessionData(authenticationResponse, {\n        devMode: __privateGet(this, _devMode)\n      });\n      __privateMethod(this, _Client_instances, onRefresh_fn).call(this, authenticationResponse);\n      return authenticationResponse;\n    });\n  } catch (error) {\n    if (error instanceof LockError && error.name === \"AcquisitionTimeoutError\") {\n      console.warn(\"Couldn't acquire refresh lock.\");\n      __privateSet(this, _state, beginningState);\n      throw error;\n    }\n    if (beginningState.tag !== \"INITIAL\") {\n      console.debug(error);\n    }\n    if (error instanceof RefreshError) {\n      removeSessionData({\n        devMode: __privateGet(this, _devMode)\n      });\n      beginningState.tag !== \"INITIAL\" && __privateGet(this, _onRefreshFailure) && __privateGet(this, _onRefreshFailure).call(this, {\n        signIn: this.signIn.bind(this)\n      });\n      __privateSet(this, _state, {\n        tag: \"ERROR\"\n      });\n    } else {\n      __privateSet(this, _state, {\n        tag: \"AUTHENTICATED\"\n      });\n    }\n    throw error;\n  }\n};\nshouldRefresh_fn = function () {\n  switch (__privateGet(this, _state).tag) {\n    case \"INITIAL\":\n    case \"AUTHENTICATING\":\n      return true;\n    case \"ERROR\":\n      return false;\n    case \"AUTHENTICATED\":\n      const accessToken = memoryStorage.getItem(storageKeys.accessToken);\n      const expiresAt = memoryStorage.getItem(storageKeys.expiresAt);\n      if (!accessToken || !expiresAt) {\n        return true;\n      }\n      const tokenRefreshBufferInSeconds = __privateGet(this, _refreshBufferInterval) * 1e3;\n      const refreshTime = expiresAt - tokenRefreshBufferInSeconds;\n      return refreshTime < Date.now();\n  }\n};\ngetAuthorizationUrl_fn = async function ({\n  context,\n  invitationToken,\n  loginHint,\n  organizationId,\n  passwordResetToken,\n  state,\n  type\n}) {\n  const {\n    codeVerifier,\n    codeChallenge\n  } = await createPkceChallenge();\n  window.sessionStorage.setItem(storageKeys.codeVerifier, codeVerifier);\n  const url = __privateGet(this, _httpClient).getAuthorizationUrl({\n    codeChallenge,\n    codeChallengeMethod: \"S256\",\n    context,\n    invitationToken,\n    loginHint,\n    organizationId,\n    passwordResetToken,\n    redirectUri: __privateGet(this, _redirectUri),\n    screenHint: type,\n    state: state ? JSON.stringify(state) : void 0\n  });\n  return url;\n};\ngetAccessToken_fn = function () {\n  return memoryStorage.getItem(storageKeys.accessToken);\n};\nuseCookie_get = function () {\n  return !__privateGet(this, _devMode);\n};\nonRefresh_fn = async function (authenticationResponse) {\n  if (__privateGet(this, _onRefreshCallback)) {\n    const {\n      refreshToken: _refreshToken,\n      ...onRefreshData\n    } = authenticationResponse;\n    __privateGet(this, _onRefreshCallback).call(this, onRefreshData);\n  }\n};\nasync function createClient(clientId, options = {}) {\n  const client = new Client(clientId, options);\n  await client.initialize();\n  return client;\n}\nexport { AuthKitError, LoginRequiredError, createClient, getClaims };","map":{"version":3,"names":["NoClientIdProvidedException","Error","constructor","arguments","status","name","message","isRedirectCallback","redirectUri","searchParams","hasCode","has","pathname","currentPathName","window","location","redirectPathname","URL","createMemoryStorage","_store","setItem","key","value","getItem","removeItem","reset","memoryStorage","createPkceChallenge","codeVerifier","createCodeVerifier","codeChallenge","createCodeChallenge","randomBytes","crypto","getRandomValues","Uint32Array","base64urlEncode","hashed","sha256","buffer","btoa","Array","from","Uint8Array","b","String","fromCharCode","join","replace","plain","encoder","TextEncoder","data","encode","subtle","digest","decodeBase64Url","input","base64","padding","repeat","length","atob","decodeJwt","token","parts","split","header","JSON","parse","payload","error","storageKeys","user","accessToken","refreshToken","expiresAt","getClaims","setSessionData","devMode","localStorage","exp","iat","expiresIn","Date","now","removeSessionData","getRefreshToken","toQueryString","options","URLSearchParams","keys","Object","sort","append","toString","AuthKitError","RefreshError","CodeExchangeError","LoginRequiredError","ProcessLocking","_ProcessLocking","locked","Map","addToLocked","toAdd","callbacks","get","set","unshift","isLocked","lock","Promise","resolve","reject","unlock","delete","toCall","pop","setTimeout","getInstance","instance","getLock","LOCK_STORAGE_KEY","DEFAULT_STORAGE_HANDLER","index","clear","keySync","getItemSync","clearSync","removeItemSync","setItemSync","delay","milliseconds","generateRandomString","CHARS","randomstring","i","INDEX","Math","floor","random","getLockId","_SuperTokensLock","storageHandler","acquiredIatSet","Set","id","acquireLock","bind","releaseLock","releaseLock__private__","waitForSomethingToChange","refreshLockWhileAcquired","waiters","lockKey","timeout","MAX_TIME","STORAGE_KEY","STORAGE","lockObj","TIMEOUT_KEY","stringify","timeoutKey","timeAcquired","timeRefreshed","lockObjPostDelay","parsedLockObjPostDelay","add","lockCorrector","storageKey","parsedLockObj","resolvedCalled","startedAt","MIN_TIME_TO_WAIT","removedListeners","stopWaiting","removeEventListener","removeFromWaiting","clearTimeout","timeOutId","timeToWait","addEventListener","addToWaiting","max","func","push","filter","notifyWaiters","forEach","parsedlockObj","MIN_ALLOWED_TIME","KEYS","currIndex","LOCK_KEY","includes","SuperTokensLock","DEFAULT_LOCK_TIMEOUT_MS","withLock","lockName","callback","TypeError","navigator","withNativeLock","withVendorLock","locks","request","signal","AbortSignal","DOMException","LockError","type","deserializeUser","object","email","emailVerified","email_verified","firstName","first_name","profilePictureUrl","profile_picture_url","lastName","last_name","lastSignInAt","last_sign_in_at","externalId","external_id","createdAt","created_at","updatedAt","updated_at","deserializeAuthenticationResponse","authenticationResponse","organization_id","access_token","refresh_token","impersonator","rest","organizationId","DEFAULT_HOSTNAME","_baseUrl","_clientId","_HttpClient_instances","post_fn","HttpClient","clientId","hostname","port","https","__privateAdd","__privateSet","authenticateWithRefreshToken","useCookie","response","__privateMethod","call","body","client_id","__privateGet","grant_type","ok","json","error_description","authenticateWithCode","code","code_verifier","getAuthorizationUrl","connectionId","context","domainHint","loginHint","provider","state","screenHint","passwordResetToken","invitationToken","codeChallengeMethod","console","warn","query","connection_id","domain_hint","login_hint","redirect_uri","response_type","screen_hint","invitation_token","password_reset_token","code_challenge","code_challenge_method","getLogoutUrl","sessionId","returnTo","url","WeakMap","WeakSet","path","fetch","method","credentials","headers","Accept","ORGANIZATION_ID_SESSION_STORAGE_KEY","REFRESH_LOCK_NAME","_state","_refreshTimer","_httpClient","_redirectUri","_devMode","_onBeforeAutoRefresh","_onRedirectCallback","_onRefreshCallback","_onRefreshFailure","_refreshBufferInterval","_Client_instances","handleCallback_fn","scheduleAutomaticRefresh_fn","refreshSession_fn","doRefresh_fn","shouldRefresh_fn","getAuthorizationUrl_fn","getAccessToken_fn","useCookie_get","onRefresh_fn","Client","apiHostname","origin","onBeforeAutoRefresh","document","hidden","onRedirectCallback","_","onRefresh","onRefreshFailure","refreshBufferInterval","tag","initialize","search","cookie","getSignInUrl","opts","getSignUpUrl","signIn","assign","signUp","signOut","navigate","sid","mode","catch","finally","getAccessToken","forceRefresh","err","getUser","dispose","switchToOrganization","signInOpts","href","stateParam","sessionStorage","cleanUrl","history","replaceState","e","debug","beginningState","org_id","tokenRefreshBufferInSeconds","refreshTime","_refreshToken","onRefreshData","createClient","client"],"sources":["/Users/phillip/Development/pricing-calculator/frontend/node_modules/@workos-inc/authkit-js/src/exceptions/no-client-id-provided.exception.ts","/Users/phillip/Development/pricing-calculator/frontend/node_modules/@workos-inc/authkit-js/src/utils/is-redirect-callback.ts","/Users/phillip/Development/pricing-calculator/frontend/node_modules/@workos-inc/authkit-js/src/utils/memory-storage.ts","/Users/phillip/Development/pricing-calculator/frontend/node_modules/@workos-inc/authkit-js/src/utils/pkce.ts","/Users/phillip/Development/pricing-calculator/frontend/node_modules/@workos-inc/authkit-js/src/utils/jwt.ts","/Users/phillip/Development/pricing-calculator/frontend/node_modules/@workos-inc/authkit-js/src/utils/storage-keys.ts","/Users/phillip/Development/pricing-calculator/frontend/node_modules/@workos-inc/authkit-js/src/utils/session-data.ts","/Users/phillip/Development/pricing-calculator/frontend/node_modules/@workos-inc/authkit-js/src/utils/to-query-string.ts","/Users/phillip/Development/pricing-calculator/frontend/node_modules/@workos-inc/authkit-js/src/errors.ts","/Users/phillip/Development/pricing-calculator/frontend/node_modules/@workos-inc/authkit-js/src/vendor/browser-tabs-lock/processLock.ts","/Users/phillip/Development/pricing-calculator/frontend/node_modules/@workos-inc/authkit-js/src/vendor/browser-tabs-lock/index.ts","/Users/phillip/Development/pricing-calculator/frontend/node_modules/@workos-inc/authkit-js/src/utils/locking.ts","/Users/phillip/Development/pricing-calculator/frontend/node_modules/@workos-inc/authkit-js/src/serializers/user.serializer.ts","/Users/phillip/Development/pricing-calculator/frontend/node_modules/@workos-inc/authkit-js/src/serializers/authentication-response.serializer.ts","/Users/phillip/Development/pricing-calculator/frontend/node_modules/@workos-inc/authkit-js/src/http-client.ts","/Users/phillip/Development/pricing-calculator/frontend/node_modules/@workos-inc/authkit-js/src/create-client.ts"],"sourcesContent":["export class NoClientIdProvidedException extends Error {\n  readonly status: number = 500;\n  readonly name: string = \"NoClientIdProvidedException\";\n  readonly message: string = `Missing Client ID. Pass it to the constructor (createClient(\"client_01HXRMBQ9BJ3E7QSTQ9X2PHVB7\"))`;\n}\n","export function isRedirectCallback(\n  redirectUri: string,\n  searchParams: URLSearchParams,\n) {\n  const hasCode = searchParams.has(\"code\");\n  if (!hasCode) return false;\n\n  const { pathname: currentPathName } = window.location;\n  const redirectPathname = new URL(redirectUri).pathname;\n  return (\n    currentPathName === redirectPathname ||\n    currentPathName === `${redirectPathname}/`\n  );\n}\n","function createMemoryStorage() {\n  let _store: { [key: string]: unknown } = {};\n\n  function setItem(key: string, value: unknown): void {\n    _store[key] = value;\n  }\n\n  function getItem(key: string): unknown {\n    return _store[key];\n  }\n\n  function removeItem(key: string): void {\n    delete _store[key];\n  }\n\n  function reset(): void {\n    _store = {};\n  }\n\n  return {\n    setItem,\n    getItem,\n    removeItem,\n    reset,\n  };\n}\n\nconst memoryStorage = createMemoryStorage();\n\nexport { memoryStorage };\n","export async function createPkceChallenge() {\n  const codeVerifier = createCodeVerifier();\n  const codeChallenge = await createCodeChallenge(codeVerifier);\n\n  return { codeVerifier, codeChallenge };\n}\n\nfunction createCodeVerifier() {\n  const randomBytes = crypto.getRandomValues(new Uint32Array(96));\n  return base64urlEncode(randomBytes);\n}\n\nasync function createCodeChallenge(codeVerifier: string) {\n  const hashed = await sha256(codeVerifier);\n  return base64urlEncode(hashed);\n}\n\nfunction base64urlEncode(buffer: ArrayBuffer): string {\n  return btoa(\n    Array.from(new Uint8Array(buffer), (b) => String.fromCharCode(b)).join(\"\"),\n  )\n    .replace(/\\+/g, \"-\")\n    .replace(/\\//g, \"_\")\n    .replace(/=+$/, \"\");\n}\n\nfunction sha256(plain: string): Promise<ArrayBuffer> {\n  const encoder = new TextEncoder();\n  const data = encoder.encode(plain);\n  return crypto.subtle.digest(\"SHA-256\", data);\n}\n","import { JWTHeader, JWTPayload } from \"../interfaces/jwt.interface\";\n\n/**\n * Decodes a base64url encoded string\n * @param input The base64url string to decode\n * @returns The decoded string\n */\nfunction decodeBase64Url(input: string): string {\n  const base64 = input.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  const padding = \"=\".repeat((4 - (base64.length % 4)) % 4);\n  return atob(base64 + padding);\n}\n\n/**\n * Decodes a JWT token and returns its header and payload\n * @param token The JWT token to decode\n * @return An object containing the decoded header and payload\n * @throws Error if the token is not in a valid JWT format or if decoding fails\n */\n// should replace this with jose if we ever need to verify the JWT\nexport function decodeJwt<T = {}>(\n  token: string,\n): {\n  header: JWTHeader;\n  payload: JWTPayload & T;\n} {\n  const parts = token.split(\".\");\n\n  if (parts.length !== 3) {\n    throw new Error(\"Invalid JWT format\");\n  }\n\n  try {\n    const header = JSON.parse(decodeBase64Url(parts[0])) as JWTHeader;\n    const payload = JSON.parse(decodeBase64Url(parts[1])) as JWTPayload & T;\n\n    return { header, payload };\n  } catch (error) {\n    throw new Error(\n      `Failed to decode JWT: ${error instanceof Error ? error.message : String(error)}`,\n    );\n  }\n}\n","export const storageKeys = {\n  codeVerifier: \"workos:code-verifier\",\n  user: \"workos:user\",\n  accessToken: \"workos:access-token\",\n  refreshToken: \"workos:refresh-token\",\n  expiresAt: \"workos:expires-at\",\n} as const;\n","import { AuthenticationResponse, JWTPayload } from \"../interfaces\";\nimport { decodeJwt } from \"./jwt\";\nimport { memoryStorage } from \"./memory-storage\";\nimport { storageKeys } from \"./storage-keys\";\n\n/**\n * Retrieves the claims from a JWT access token.\n * @param accessToken - The JWT access token to decode.\n * @returns The decoded JWT payload, which includes the claims.\n */\nexport function getClaims<T = {}>(accessToken: string): JWTPayload & T {\n  return decodeJwt<T>(accessToken).payload;\n}\n\nexport function setSessionData(\n  data: AuthenticationResponse,\n  { devMode = false } = {},\n) {\n  const { user, accessToken, refreshToken } = data;\n  memoryStorage.setItem(storageKeys.user, user);\n  memoryStorage.setItem(storageKeys.accessToken, accessToken);\n  (devMode ? window.localStorage : memoryStorage).setItem(\n    storageKeys.refreshToken,\n    refreshToken,\n  );\n\n  // compute a local time version of expires at (should avoid issues with slightly-wrong clocks)\n  const { exp, iat } = getClaims(accessToken);\n  const expiresIn = exp - iat;\n  const expiresAt = Date.now() + expiresIn * 1000;\n  memoryStorage.setItem(storageKeys.expiresAt, expiresAt);\n}\n\nexport function removeSessionData({ devMode = false } = {}) {\n  memoryStorage.removeItem(storageKeys.user);\n  memoryStorage.removeItem(storageKeys.accessToken);\n  (devMode ? window.localStorage : memoryStorage).removeItem(\n    storageKeys.refreshToken,\n  );\n}\n\nexport function getRefreshToken({ devMode = false } = {}) {\n  return (devMode ? window.localStorage : memoryStorage).getItem(\n    storageKeys.refreshToken,\n  ) as string | undefined;\n}\n","export function toQueryString(\n  options: Record<string, string | undefined>,\n): string {\n  const searchParams = new URLSearchParams();\n  const keys = Object.keys(options).sort();\n\n  for (const key of keys) {\n    const value = options[key];\n\n    if (value) {\n      searchParams.append(key, value);\n    }\n  }\n\n  return searchParams.toString();\n}\n","export class AuthKitError extends Error {}\nexport class RefreshError extends AuthKitError {}\nexport class CodeExchangeError extends AuthKitError {}\nexport class LoginRequiredError extends AuthKitError {\n  readonly message: string = \"No access token available\";\n}\n","declare let setTimeout: any;\nclass ProcessLocking {\n    static instance: undefined | ProcessLocking;\n    private locked: Map<string, (() => void)[]> = new Map<string, (() => void)[]>();\n\n\n    static getInstance() {\n        if (ProcessLocking.instance === undefined) {\n            ProcessLocking.instance = new ProcessLocking();\n        }\n        return ProcessLocking.instance;\n    }\n\n    private addToLocked = (key: string, toAdd?: () => void) => {\n        let callbacks = this.locked.get(key);\n        if (callbacks === undefined) {\n            if (toAdd === undefined) {\n                this.locked.set(key, []);\n            } else {\n                this.locked.set(key, [toAdd]);\n            }\n        } else {\n            if (toAdd !== undefined) {\n                callbacks.unshift(toAdd);\n                this.locked.set(key, callbacks);\n            }\n        }\n    }\n\n    isLocked = (key: string): boolean => {\n        return this.locked.has(key);\n    }\n\n    lock = (key: string): Promise<void> => {\n        return new Promise<void>((resolve, reject) => {\n            if (this.isLocked(key)) {\n                this.addToLocked(key, resolve);\n            } else {\n                this.addToLocked(key);\n                resolve();\n            }\n        });\n    }\n\n    unlock = (key: string) => {\n        let callbacks = this.locked.get(key);\n        if (callbacks === undefined || callbacks.length === 0) {\n            this.locked.delete(key);\n            return;\n        }\n        let toCall = callbacks.pop();\n        this.locked.set(key, callbacks);\n        if (toCall !== undefined) {\n            setTimeout(toCall, 0);\n        }\n    }\n}\n\nexport default function getLock(): ProcessLocking {\n    return ProcessLocking.getInstance();\n}","import getProcessLock from './processLock';\n\n/**\n * @author: SuperTokens (https://github.com/supertokens)\n * This library was created as a part of a larger project, SuperTokens(https://supertokens.io) - the best session management solution.\n * You can also check out our other projects on https://github.com/supertokens\n * \n * To contribute to this package visit https://github.com/supertokens/browser-tabs-lock\n * If you face any problems you can file an issue on https://github.com/supertokens/browser-tabs-lock/issues\n * \n * If you have any questions or if you just want to say hi visit https://supertokens.io/discord\n */\n\n\n/**\n * @constant\n * @type {string}\n * @default\n * @description All the locks taken by this package will have this as prefix\n*/\nconst LOCK_STORAGE_KEY = 'browser-tabs-lock-key';\n\ndeclare let setTimeout: any;\ndeclare let window: any;\ndeclare let clearTimeout: any;\n\nexport type StorageHandler = {\n    key: (index: number) => Promise<string | null>;\n    getItem: (key: string) => Promise<string | null>;\n    clear: () => Promise<void>;\n    removeItem: (key: string) => Promise<void>;\n    setItem: (key: string, value: string) => Promise<void>;\n    /**\n     * Sync versions of the storage functions\n     */\n    keySync: (index: number) => string | null;\n    getItemSync: (key: string) => string | null;\n    clearSync: () => void;\n    removeItemSync: (key: string) => void;\n    setItemSync: (key: string, value: string) => void;\n};\n\nconst DEFAULT_STORAGE_HANDLER: StorageHandler = {\n    key: async (index: number) => {\n        throw new Error(\"Unsupported\");\n    },\n    getItem: async (key: string) => {\n        throw new Error(\"Unsupported\");\n    },\n    clear: async () => {\n        return window.localStorage.clear();\n    },\n    removeItem: async (key: string) => {\n        throw new Error(\"Unsupported\");\n    },\n    setItem: async (key: string, value: string) => {\n        throw new Error(\"Unsupported\");\n    },\n    keySync: (index: number) => {\n        return window.localStorage.key(index);\n    },\n    getItemSync: (key: string) => {\n        return window.localStorage.getItem(key);\n    },\n    clearSync: () => {\n        return window.localStorage.clear();\n    },\n    removeItemSync: (key: string) => {\n        return window.localStorage.removeItem(key);\n    },\n    setItemSync: (key: string, value: string) => {\n        return window.localStorage.setItem(key, value);\n    },\n\n}\n\n/**\n * @function delay\n * @param {number} milliseconds - How long the delay should be in terms of milliseconds\n * @returns {Promise<void>} \n */\nfunction delay(milliseconds: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, milliseconds));\n}\n\n/**\n * @function generateRandomString\n * @params {number} length - How long the random string should be\n * @returns {string}\n * @description returns random string whose length is equal to the length passed as parameter\n */\nfunction generateRandomString(length: number): string {\n    const CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz';\n    let randomstring = '';\n    for (let i = 0; i < length; i++) {\n        const INDEX = Math.floor(Math.random() * CHARS.length);\n        randomstring += CHARS[INDEX];\n    }\n    return randomstring;\n}\n\n/**\n * @function getLockId\n * @returns {string}\n * @description Generates an id which will be unique for the browser tab\n */\nfunction getLockId(): string {\n    return Date.now().toString() + generateRandomString(15)\n}\n\nexport default class SuperTokensLock {\n    private static waiters: Array<any> | undefined = undefined;\n    private id: string;\n    private acquiredIatSet: Set<String> = new Set<String>();\n    private storageHandler: StorageHandler | undefined = undefined;\n\n    constructor(storageHandler?: StorageHandler) {\n        this.id = getLockId();\n        this.acquireLock = this.acquireLock.bind(this);\n        this.releaseLock = this.releaseLock.bind(this);\n        this.releaseLock__private__ = this.releaseLock__private__.bind(this);\n        this.waitForSomethingToChange = this.waitForSomethingToChange.bind(this);\n        this.refreshLockWhileAcquired = this.refreshLockWhileAcquired.bind(this);\n        this.storageHandler = storageHandler;\n        if (SuperTokensLock.waiters === undefined) {\n            SuperTokensLock.waiters = [];\n        }\n    }\n\n    /**\n     * @async\n     * @memberOf Lock\n     * @function acquireLock\n     * @param {string} lockKey - Key for which the lock is being acquired\n     * @param {number} [timeout=5000] - Maximum time for which the function will wait to acquire the lock\n     * @returns {Promise<boolean>}\n     * @description Will return true if lock is being acquired, else false.\n     *              Also the lock can be acquired for maximum 10 secs\n     */\n    async acquireLock(lockKey: string, timeout: number = 5000) {\n        let iat = Date.now() + generateRandomString(4);\n        const MAX_TIME = Date.now() + timeout;\n        const STORAGE_KEY = `${LOCK_STORAGE_KEY}-${lockKey}`;\n        const STORAGE: StorageHandler = this.storageHandler === undefined ? DEFAULT_STORAGE_HANDLER : this.storageHandler;\n        while (Date.now() < MAX_TIME) {\n            await delay(30);\n            let lockObj = STORAGE.getItemSync(STORAGE_KEY);\n            if (lockObj === null) {\n                const TIMEOUT_KEY = `${this.id}-${lockKey}-${iat}`;\n                // there is a problem if setItem happens at the exact same time for 2 different processes.. so we add some random delay here.\n                await delay(Math.floor(Math.random() * 25));\n                STORAGE.setItemSync(STORAGE_KEY, JSON.stringify({\n                    id: this.id,\n                    iat,\n                    timeoutKey: TIMEOUT_KEY,\n                    timeAcquired: Date.now(),\n                    timeRefreshed: Date.now()\n                }));\n                await delay(30);    // this is to prevent race conditions. This time must be more than the time it takes for storage.setItem\n                let lockObjPostDelay = STORAGE.getItemSync(STORAGE_KEY);\n                if (lockObjPostDelay !== null) {\n                    let parsedLockObjPostDelay = JSON.parse(lockObjPostDelay);\n                    if (parsedLockObjPostDelay.id === this.id && parsedLockObjPostDelay.iat === iat) {\n                        this.acquiredIatSet.add(iat);\n                        this.refreshLockWhileAcquired(STORAGE_KEY, iat);\n                        return true;\n                    }\n                }\n            } else {\n                SuperTokensLock.lockCorrector(this.storageHandler === undefined ? DEFAULT_STORAGE_HANDLER : this.storageHandler);\n                await this.waitForSomethingToChange(MAX_TIME);\n\n            }\n            iat = Date.now() + generateRandomString(4);\n        }\n        return false;\n    }\n\n    private async refreshLockWhileAcquired(storageKey: string, iat: string) {\n        setTimeout(async () => {\n            await getProcessLock().lock(iat);\n            if (!this.acquiredIatSet.has(iat)) {\n                getProcessLock().unlock(iat);\n                return;\n            }\n            const STORAGE: StorageHandler = this.storageHandler === undefined ? DEFAULT_STORAGE_HANDLER : this.storageHandler;\n            let lockObj = STORAGE.getItemSync(storageKey);\n            if (lockObj !== null) {\n                let parsedLockObj = JSON.parse(lockObj);\n                parsedLockObj.timeRefreshed = Date.now();\n                STORAGE.setItemSync(storageKey, JSON.stringify(parsedLockObj));\n                getProcessLock().unlock(iat);\n            } else {\n                getProcessLock().unlock(iat);\n                return;\n            }\n            this.refreshLockWhileAcquired(storageKey, iat);\n        }, 1000);\n    }\n\n    private async waitForSomethingToChange(MAX_TIME: number) {\n        await new Promise(resolve => {\n            let resolvedCalled = false;\n            let startedAt = Date.now();\n            const MIN_TIME_TO_WAIT = 50;    // ms\n            let removedListeners = false;\n            function stopWaiting() {\n                if (!removedListeners) {\n                    window.removeEventListener('storage', stopWaiting);\n                    SuperTokensLock.removeFromWaiting(stopWaiting);\n                    clearTimeout(timeOutId);\n                    removedListeners = true;\n                }\n                if (!resolvedCalled) {\n                    resolvedCalled = true;\n                    let timeToWait = MIN_TIME_TO_WAIT - (Date.now() - startedAt);\n                    if (timeToWait > 0) {\n                        setTimeout(resolve, timeToWait);\n                    } else {\n                        resolve(null);\n                    }\n                }\n            }\n            window.addEventListener('storage', stopWaiting);\n            SuperTokensLock.addToWaiting(stopWaiting);\n            let timeOutId = setTimeout(stopWaiting, Math.max(0, MAX_TIME - Date.now()));\n        });\n    }\n\n    private static addToWaiting(func: any) {\n        this.removeFromWaiting(func);\n        if (SuperTokensLock.waiters === undefined) {\n            return;\n        }\n        SuperTokensLock.waiters.push(func);\n    }\n\n    private static removeFromWaiting(func: any) {\n        if (SuperTokensLock.waiters === undefined) {\n            return;\n        }\n        SuperTokensLock.waiters = SuperTokensLock.waiters.filter(i => i !== func);\n    }\n\n    private static notifyWaiters() {\n        if (SuperTokensLock.waiters === undefined) {\n            return;\n        }\n        let waiters = [...SuperTokensLock.waiters];    // so that if Lock.waiters is changed it's ok.\n        waiters.forEach(i => i());\n    }\n\n    /**\n     * @function releaseLock\n     * @memberOf Lock\n     * @param {string} lockKey - Key for which lock is being released\n     * @returns {void}\n     * @description Release a lock.\n     */\n    async releaseLock(lockKey: string) {\n        return await this.releaseLock__private__(lockKey);\n    }\n\n    /**\n     * @function releaseLock\n     * @memberOf Lock\n     * @param {string} lockKey - Key for which lock is being released\n     * @returns {void}\n     * @description Release a lock.\n     */\n    private async releaseLock__private__(lockKey: string) {\n        const STORAGE: StorageHandler = this.storageHandler === undefined ? DEFAULT_STORAGE_HANDLER : this.storageHandler;\n        const STORAGE_KEY = `${LOCK_STORAGE_KEY}-${lockKey}`;\n        let lockObj = STORAGE.getItemSync(STORAGE_KEY);\n        if (lockObj === null) {\n            return;\n        }\n        let parsedlockObj = JSON.parse(lockObj);\n        if (parsedlockObj.id === this.id) {\n            await getProcessLock().lock(parsedlockObj.iat);\n\n            this.acquiredIatSet.delete(parsedlockObj.iat);\n            STORAGE.removeItemSync(STORAGE_KEY);\n\n            getProcessLock().unlock(parsedlockObj.iat);\n\n            SuperTokensLock.notifyWaiters();\n        }\n    }\n\n    /**\n     * @function lockCorrector\n     * @returns {void}\n     * @description If a lock is acquired by a tab and the tab is closed before the lock is\n     *              released, this function will release those locks\n     */\n    private static lockCorrector(storageHandler: StorageHandler) {\n        const MIN_ALLOWED_TIME = Date.now() - 5000;\n        const STORAGE = storageHandler;\n        const KEYS: string[] = [];\n        let currIndex = 0;\n        while (true) {\n            let key = STORAGE.keySync(currIndex);\n            if (key === null) {\n                break;\n            }\n            KEYS.push(key);\n            currIndex++;\n        }\n        let notifyWaiters = false;\n        for (let i = 0; i < KEYS.length; i++) {\n            const LOCK_KEY = KEYS[i];\n            if (LOCK_KEY.includes(LOCK_STORAGE_KEY)) {\n                let lockObj = STORAGE.getItemSync(LOCK_KEY);\n                if (lockObj !== null) {\n                    let parsedlockObj = JSON.parse(lockObj);\n                    if ((parsedlockObj.timeRefreshed === undefined && parsedlockObj.timeAcquired < MIN_ALLOWED_TIME) ||\n                        (parsedlockObj.timeRefreshed !== undefined && parsedlockObj.timeRefreshed < MIN_ALLOWED_TIME)) {\n                        STORAGE.removeItemSync(LOCK_KEY);\n                        notifyWaiters = true;\n                    }\n                }\n            }\n        }\n        if (notifyWaiters) {\n            SuperTokensLock.notifyWaiters();\n        }\n    }\n}\n","import Lock from \"../vendor/browser-tabs-lock\";\n\nconst DEFAULT_LOCK_TIMEOUT_MS = 10_000;\n\nexport function withLock<T>(\n  lockName: string,\n  callback: () => T | Promise<T>,\n  { timeout = DEFAULT_LOCK_TIMEOUT_MS } = {},\n): Promise<T> {\n  if (!lockName) {\n    throw new TypeError(\"lockName is required and must be a non-empty string.\");\n  }\n\n  return \"locks\" in navigator\n    ? withNativeLock(lockName, callback, timeout)\n    : withVendorLock(lockName, callback, timeout);\n}\n\nasync function withNativeLock<T>(\n  lockName: string,\n  callback: () => T | Promise<T>,\n  timeout: number,\n) {\n  try {\n    return await navigator.locks.request(\n      lockName,\n      { signal: AbortSignal.timeout(timeout) },\n      callback,\n    );\n  } catch (error) {\n    if (error instanceof DOMException) {\n      switch (error.name) {\n        case \"AbortError\":\n          throw new LockError(\"AcquisitionTimeoutError\", lockName, \"Native\");\n\n        case \"InvalidStateError\":\n        case \"NotSupportedError\":\n        case \"SecurityError\":\n        // These are documented but we currently don't handle them\n        // in any particular way and let them bubble up.\n      }\n    }\n\n    throw error;\n  }\n}\n\nasync function withVendorLock<T>(\n  lockName: string,\n  callback: () => T | Promise<T>,\n  timeout: number,\n) {\n  const lock = new Lock();\n\n  try {\n    if (await lock.acquireLock(lockName, timeout)) {\n      return await callback();\n    } else {\n      throw new LockError(\"AcquisitionTimeoutError\", lockName, \"Vendor\");\n    }\n  } finally {\n    await lock.releaseLock(lockName);\n  }\n}\n\nexport class LockError extends Error {\n  constructor(\n    override readonly name: \"AcquisitionTimeoutError\",\n    readonly lockName: string,\n    type: \"Native\" | \"Vendor\",\n  ) {\n    super(`Lock acquisition timed out for \"${lockName}\" (${type})`);\n  }\n}\n","import { User, UserRaw } from \"../interfaces\";\n\nexport const deserializeUser = (user: UserRaw): User => ({\n  object: user.object,\n  id: user.id,\n  email: user.email,\n  emailVerified: user.email_verified,\n  firstName: user.first_name,\n  profilePictureUrl: user.profile_picture_url,\n  lastName: user.last_name,\n  lastSignInAt: user.last_sign_in_at,\n  externalId: user.external_id,\n  createdAt: user.created_at,\n  updatedAt: user.updated_at,\n});\n","import {\n  AuthenticationResponse,\n  AuthenticationResponseRaw,\n} from \"../interfaces\";\nimport { deserializeUser } from \"./user.serializer\";\n\nexport const deserializeAuthenticationResponse = (\n  authenticationResponse: AuthenticationResponseRaw,\n): AuthenticationResponse => {\n  const {\n    user,\n    organization_id,\n    access_token,\n    refresh_token,\n    impersonator,\n    ...rest\n  } = authenticationResponse;\n\n  return {\n    user: deserializeUser(user),\n    organizationId: organization_id,\n    accessToken: access_token,\n    refreshToken: refresh_token,\n    impersonator,\n    ...rest,\n  };\n};\n","import { CodeExchangeError, RefreshError } from \"./errors\";\nimport {\n  AuthenticationResponseRaw,\n  GetAuthorizationUrlOptions,\n} from \"./interfaces\";\nimport { deserializeAuthenticationResponse } from \"./serializers\";\nimport { toQueryString } from \"./utils\";\n\nconst DEFAULT_HOSTNAME = \"api.workos.com\";\n\nexport class HttpClient {\n  readonly #baseUrl: string;\n  readonly #clientId: string;\n\n  constructor({\n    clientId,\n    hostname = DEFAULT_HOSTNAME,\n    port,\n    https = true,\n  }: {\n    clientId: string;\n    hostname?: string;\n    port?: number;\n    https?: boolean;\n  }) {\n    this.#baseUrl = `${https ? \"https\" : \"http\"}://${hostname}${\n      port ? `:${port}` : \"\"\n    }`;\n    this.#clientId = clientId;\n  }\n\n  async authenticateWithRefreshToken({\n    refreshToken,\n    organizationId,\n    useCookie,\n  }: {\n    refreshToken: string | undefined;\n    organizationId?: string;\n    useCookie: boolean;\n  }) {\n    const response = await this.#post(\"/user_management/authenticate\", {\n      useCookie,\n      body: {\n        client_id: this.#clientId,\n        grant_type: \"refresh_token\",\n        ...(!useCookie && { refresh_token: refreshToken }),\n        organization_id: organizationId,\n      },\n    });\n\n    if (response.ok) {\n      const data = (await response.json()) as AuthenticationResponseRaw;\n      return deserializeAuthenticationResponse(data);\n    } else {\n      const error = (await response.json()) as any;\n      throw new RefreshError(error.error_description);\n    }\n  }\n\n  async authenticateWithCode({\n    code,\n    codeVerifier,\n    useCookie,\n  }: {\n    code: string;\n    codeVerifier: string;\n    useCookie: boolean;\n  }) {\n    const response = await this.#post(\"/user_management/authenticate\", {\n      useCookie,\n      body: {\n        code,\n        client_id: this.#clientId,\n        grant_type: \"authorization_code\",\n        code_verifier: codeVerifier,\n      },\n    });\n\n    if (response.ok) {\n      const data = (await response.json()) as AuthenticationResponseRaw;\n      return deserializeAuthenticationResponse(data);\n    }\n\n    const error = await response.json();\n    throw new CodeExchangeError(error.error_description);\n  }\n\n  #post(\n    path: \"/user_management/authenticate\",\n    { body, useCookie }: { body: Record<string, unknown>; useCookie: boolean },\n  ) {\n    return fetch(new URL(path, this.#baseUrl), {\n      method: \"POST\",\n      ...(useCookie && { credentials: \"include\" }),\n      headers: {\n        Accept: \"application/json, text/plain, */*\",\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(body),\n    });\n  }\n\n  getAuthorizationUrl({\n    connectionId,\n    context,\n    domainHint,\n    loginHint,\n    organizationId,\n    provider = \"authkit\",\n    redirectUri,\n    state,\n    screenHint,\n    passwordResetToken,\n    invitationToken,\n    codeChallenge,\n    codeChallengeMethod,\n  }: GetAuthorizationUrlOptions) {\n    if (!provider && !connectionId && !organizationId) {\n      throw new TypeError(\n        `Incomplete arguments. Need to specify either a 'connectionId', 'organizationId', or 'provider'.`,\n      );\n    }\n\n    if (provider !== \"authkit\" && screenHint) {\n      throw new TypeError(\n        `'screenHint' is only supported for 'authkit' provider`,\n      );\n    }\n\n    if (context) {\n      console.warn(\n        `\\`context\\` is deprecated. We previously required initiate login endpoints to return the\n\\`context\\` query parameter when getting the authorization URL. This is no longer necessary.`,\n      );\n    }\n\n    const query = toQueryString({\n      connection_id: connectionId,\n      organization_id: organizationId,\n      domain_hint: domainHint,\n      login_hint: loginHint,\n      provider,\n      client_id: this.#clientId,\n      redirect_uri: redirectUri,\n      response_type: \"code\",\n      state,\n      screen_hint: screenHint,\n      invitation_token: invitationToken,\n      password_reset_token: passwordResetToken,\n      code_challenge: codeChallenge,\n      code_challenge_method: codeChallengeMethod,\n    });\n\n    return `${this.#baseUrl}/user_management/authorize?${query}`;\n  }\n\n  getLogoutUrl({\n    sessionId,\n    returnTo,\n  }: {\n    sessionId: string;\n    returnTo: string | undefined;\n  }) {\n    const url = new URL(\"/user_management/sessions/logout\", this.#baseUrl);\n\n    url.searchParams.set(\"session_id\", sessionId);\n    if (returnTo) {\n      url.searchParams.set(\"return_to\", returnTo);\n    }\n\n    return url;\n  }\n}\n","import {\n  AuthenticationResponse,\n  CreateClientOptions,\n  OnRefreshResponse,\n  User,\n} from \"./interfaces\";\nimport { NoClientIdProvidedException } from \"./exceptions\";\nimport {\n  isRedirectCallback,\n  memoryStorage,\n  createPkceChallenge,\n  setSessionData,\n  removeSessionData,\n  storageKeys,\n} from \"./utils\";\nimport { getRefreshToken, getClaims } from \"./utils/session-data\";\nimport { RedirectParams } from \"./interfaces/create-client-options.interface\";\nimport { LoginRequiredError, RefreshError } from \"./errors\";\nimport { withLock, LockError } from \"./utils/locking\";\nimport { HttpClient } from \"./http-client\";\n\ninterface RedirectOptions {\n  /**\n   *  @deprecated We previously required initiate login endpoints to return the `context`\n   *  query parameter when getting the authorization URL. This is no longer necessary.\n   */\n  context?: string;\n  invitationToken?: string;\n  loginHint?: string;\n  organizationId?: string;\n  passwordResetToken?: string;\n  state?: any;\n  type: \"sign-in\" | \"sign-up\";\n}\n\ntype State =\n  | { tag: \"INITIAL\" }\n  | { tag: \"AUTHENTICATING\"; response: Promise<AuthenticationResponse> }\n  | { tag: \"AUTHENTICATED\" }\n  | { tag: \"ERROR\" };\n\nexport const ORGANIZATION_ID_SESSION_STORAGE_KEY = \"workos_organization_id\";\n\nconst REFRESH_LOCK_NAME = \"WORKOS_REFRESH_SESSION\";\n\nexport class Client {\n  #state: State;\n  #refreshTimer: ReturnType<typeof setTimeout> | undefined;\n\n  readonly #httpClient: HttpClient;\n  readonly #redirectUri: string;\n  readonly #devMode: boolean;\n  readonly #onBeforeAutoRefresh: () => boolean;\n  readonly #onRedirectCallback: (params: RedirectParams) => void;\n  readonly #onRefreshCallback:\n    | ((response: OnRefreshResponse) => void)\n    | undefined;\n  readonly #onRefreshFailure:\n    | ((params: { signIn: () => Promise<void> }) => void)\n    | undefined;\n  readonly #refreshBufferInterval: number;\n\n  constructor(\n    clientId: string,\n    {\n      apiHostname: hostname,\n      https,\n      port,\n      redirectUri = window.origin,\n      devMode = location.hostname === \"localhost\" ||\n        location.hostname === \"127.0.0.1\",\n      // refresh if this is true\n      onBeforeAutoRefresh = () => {\n        return !document.hidden;\n      },\n      onRedirectCallback = (_: RedirectParams) => {},\n      onRefresh,\n      onRefreshFailure,\n      refreshBufferInterval = 10,\n    }: CreateClientOptions = {},\n  ) {\n    if (!clientId) {\n      throw new NoClientIdProvidedException();\n    }\n\n    this.#httpClient = new HttpClient({ clientId, hostname, port, https });\n    this.#devMode = devMode;\n    this.#redirectUri = redirectUri;\n    this.#state = { tag: \"INITIAL\" };\n    this.#onBeforeAutoRefresh = onBeforeAutoRefresh;\n    this.#onRedirectCallback = onRedirectCallback;\n    this.#onRefreshCallback = onRefresh;\n    this.#onRefreshFailure = onRefreshFailure;\n    this.#refreshBufferInterval = refreshBufferInterval;\n  }\n\n  async initialize() {\n    if (this.#state.tag !== \"INITIAL\") {\n      return;\n    }\n\n    const searchParams = new URLSearchParams(window.location.search);\n    if (isRedirectCallback(this.#redirectUri, searchParams)) {\n      await this.#handleCallback();\n    } else if (\n      document.cookie.includes(\"workos-has-session=\") ||\n      getRefreshToken({ devMode: this.#devMode })\n    ) {\n      try {\n        await this.#refreshSession();\n        this.#scheduleAutomaticRefresh();\n      } catch {\n        // this is expected to fail if a user doesn't\n        // have a session. do nothing.\n      }\n    }\n  }\n\n  async getSignInUrl(opts: Omit<RedirectOptions, \"type\"> = {}) {\n    const url = await this.#getAuthorizationUrl({ ...opts, type: \"sign-in\" });\n    return url;\n  }\n\n  async getSignUpUrl(opts: Omit<RedirectOptions, \"type\"> = {}) {\n    const url = await this.#getAuthorizationUrl({ ...opts, type: \"sign-up\" });\n    return url;\n  }\n\n  async signIn(opts: Omit<RedirectOptions, \"type\"> = {}) {\n    const url = await this.#getAuthorizationUrl({ ...opts, type: \"sign-in\" });\n    window.location.assign(url);\n  }\n\n  async signUp(opts: Omit<RedirectOptions, \"type\"> = {}) {\n    const url = await this.#getAuthorizationUrl({ ...opts, type: \"sign-up\" });\n    window.location.assign(url);\n  }\n\n  signOut(options?: { returnTo?: string; navigate?: true }): void;\n  signOut(options?: { returnTo?: string; navigate: false }): Promise<void>;\n  signOut(\n    options: { returnTo?: string; navigate?: boolean } = { navigate: true },\n  ): void | Promise<void> {\n    const navigate = options.navigate ?? true;\n    const accessToken = memoryStorage.getItem(storageKeys.accessToken);\n    if (typeof accessToken !== \"string\") return;\n    const { sid: sessionId } = getClaims(accessToken);\n\n    const url = this.#httpClient.getLogoutUrl({\n      sessionId,\n      returnTo: options?.returnTo,\n    });\n\n    if (url) {\n      removeSessionData({ devMode: this.#devMode });\n\n      if (navigate) {\n        window.location.assign(url);\n      } else {\n        return new Promise(async (resolve) => {\n          fetch(url, {\n            mode: \"no-cors\",\n            credentials: \"include\",\n          })\n            .catch((error) => {\n              console.warn(\"AuthKit: Failed to send logout request\", error);\n            })\n            .finally(resolve);\n        });\n      }\n    }\n  }\n\n  async getAccessToken(options?: { forceRefresh?: boolean }): Promise<string> {\n    if (options?.forceRefresh || this.#shouldRefresh()) {\n      try {\n        await this.#refreshSession();\n      } catch (err) {\n        if (err instanceof RefreshError) {\n          throw new LoginRequiredError();\n        } else {\n          throw err;\n        }\n      }\n    }\n\n    const accessToken = this.#getAccessToken();\n    if (!accessToken) {\n      throw new LoginRequiredError();\n    }\n\n    return accessToken;\n  }\n\n  getUser() {\n    const user = memoryStorage.getItem(storageKeys.user);\n    return user ? (user as User) : null;\n  }\n\n  dispose() {\n    clearTimeout(this.#refreshTimer);\n    memoryStorage.reset();\n  }\n\n  async #handleCallback() {\n    if (this.#state.tag !== \"INITIAL\") {\n      return;\n    }\n\n    const url = new URL(window.location.href);\n    const code = url.searchParams.get(\"code\");\n    const stateParam = url.searchParams.get(\"state\");\n    const state = stateParam ? JSON.parse(stateParam) : undefined;\n\n    // grab the previously stored code verifier from session storage\n    const codeVerifier = window.sessionStorage.getItem(\n      storageKeys.codeVerifier,\n    );\n\n    if (code) {\n      if (codeVerifier) {\n        try {\n          this.#state = {\n            tag: \"AUTHENTICATING\",\n            response: this.#httpClient.authenticateWithCode({\n              code,\n              codeVerifier,\n              useCookie: this.#useCookie,\n            }),\n          };\n          const authenticationResponse = await this.#state.response;\n\n          if (authenticationResponse) {\n            this.#state = { tag: \"AUTHENTICATED\" };\n            this.#scheduleAutomaticRefresh();\n            setSessionData(authenticationResponse, { devMode: this.#devMode });\n            this.#onRefresh(authenticationResponse);\n            this.#onRedirectCallback({ state, ...authenticationResponse });\n          }\n        } catch (error) {\n          this.#state = { tag: \"ERROR\" };\n          console.error(error);\n        }\n      } else {\n        this.#state = { tag: \"ERROR\" };\n        console.error(`Couldn't exchange code.\n\nAn authorization_code was supplied for a login which did not originate at the application. This could happen for various reasons:\n\n* This could have been an attempted Login CSRF attack. You were not affected.\n* The developer may not have configured a Login Initiation endpoint.`);\n      }\n    }\n\n    // Remove code from search params\n    const cleanUrl = new URL(window.location.toString());\n    cleanUrl.search = \"\";\n    window.sessionStorage.removeItem(storageKeys.codeVerifier);\n    window.history.replaceState({}, \"\", cleanUrl);\n  }\n\n  async #scheduleAutomaticRefresh() {\n    this.#refreshTimer = setTimeout(() => {\n      if (this.#shouldRefresh() && this.#onBeforeAutoRefresh()) {\n        this.#refreshSession()\n          .catch((e) => {\n            console.debug(e);\n          })\n          .finally(() => this.#scheduleAutomaticRefresh());\n      } else {\n        this.#scheduleAutomaticRefresh();\n      }\n    }, 1000);\n  }\n\n  /**\n   * Switches to the requested organization.\n   *\n   * Redirects to the hosted login page for the given organization if the\n   * switch is unsuccessful.\n   */\n  async switchToOrganization({\n    organizationId,\n    signInOpts = {},\n  }: {\n    organizationId: string;\n    signInOpts?: Omit<RedirectOptions, \"type\" | \"organizationId\">;\n  }) {\n    try {\n      await this.#refreshSession({ organizationId });\n    } catch (error) {\n      if (error instanceof RefreshError) {\n        this.signIn({ ...signInOpts, organizationId });\n      } else {\n        throw error;\n      }\n    }\n  }\n\n  async #refreshSession({ organizationId }: { organizationId?: string } = {}) {\n    if (this.#state.tag === \"AUTHENTICATING\") {\n      await this.#state.response;\n      return;\n    }\n\n    const beginningState = this.#state;\n\n    this.#state = {\n      tag: \"AUTHENTICATING\",\n      response: this.#doRefresh({ organizationId, beginningState }),\n    };\n\n    await this.#state.response;\n  }\n\n  async #doRefresh({\n    organizationId,\n    beginningState,\n  }: {\n    organizationId?: string;\n    beginningState: State;\n  }): Promise<AuthenticationResponse> {\n    try {\n      return await withLock(REFRESH_LOCK_NAME, async () => {\n        if (organizationId) {\n          sessionStorage.setItem(\n            ORGANIZATION_ID_SESSION_STORAGE_KEY,\n            organizationId,\n          );\n        } else {\n          const accessToken = this.#getAccessToken();\n          if (accessToken) {\n            organizationId = getClaims(accessToken)?.org_id;\n          } else {\n            organizationId =\n              sessionStorage.getItem(ORGANIZATION_ID_SESSION_STORAGE_KEY) ??\n              undefined;\n          }\n        }\n\n        const authenticationResponse =\n          await this.#httpClient.authenticateWithRefreshToken({\n            refreshToken: getRefreshToken({ devMode: this.#devMode }),\n            organizationId,\n            useCookie: this.#useCookie,\n          });\n\n        this.#state = { tag: \"AUTHENTICATED\" };\n        setSessionData(authenticationResponse, { devMode: this.#devMode });\n        this.#onRefresh(authenticationResponse);\n        return authenticationResponse;\n      });\n    } catch (error) {\n      if (\n        error instanceof LockError &&\n        error.name === \"AcquisitionTimeoutError\"\n      ) {\n        console.warn(\"Couldn't acquire refresh lock.\");\n\n        // preserving the original state so that we can try again next time\n        this.#state = beginningState;\n        throw error;\n      }\n\n      if (beginningState.tag !== \"INITIAL\") {\n        console.debug(error);\n      }\n\n      if (error instanceof RefreshError) {\n        removeSessionData({ devMode: this.#devMode });\n        // fire the refresh failure UNLESS this is the initial refresh attempt\n        // (the initial refresh is expected to fail if a user has not logged in\n        // ever or recently)\n        beginningState.tag !== \"INITIAL\" &&\n          this.#onRefreshFailure &&\n          this.#onRefreshFailure({ signIn: this.signIn.bind(this) });\n\n        this.#state = { tag: \"ERROR\" };\n      } else {\n        // transitioning into the AUTHENTICATED state ensures that we will\n        // attempt to refresh the token on future getAccessToken calls()\n        //\n        // this could maybe be a new state for clarity? TEMPORARY_ERROR?\n        this.#state = { tag: \"AUTHENTICATED\" };\n      }\n\n      throw error;\n    }\n  }\n\n  #shouldRefresh() {\n    switch (this.#state.tag) {\n      case \"INITIAL\":\n      case \"AUTHENTICATING\":\n        return true;\n      case \"ERROR\":\n        return false;\n      case \"AUTHENTICATED\":\n        const accessToken = memoryStorage.getItem(storageKeys.accessToken) as\n          | string\n          | undefined;\n        const expiresAt = memoryStorage.getItem(storageKeys.expiresAt) as\n          | number\n          | undefined;\n\n        if (!accessToken || !expiresAt) {\n          return true;\n        }\n\n        const tokenRefreshBufferInSeconds = this.#refreshBufferInterval * 1000;\n        const refreshTime = expiresAt - tokenRefreshBufferInSeconds;\n        return refreshTime < Date.now();\n    }\n  }\n\n  async #getAuthorizationUrl({\n    context,\n    invitationToken,\n    loginHint,\n    organizationId,\n    passwordResetToken,\n    state,\n    type,\n  }: RedirectOptions) {\n    const { codeVerifier, codeChallenge } = await createPkceChallenge();\n    // store the code verifier in session storage for later use (after the redirect back from authkit)\n    window.sessionStorage.setItem(storageKeys.codeVerifier, codeVerifier);\n    const url = this.#httpClient.getAuthorizationUrl({\n      codeChallenge,\n      codeChallengeMethod: \"S256\",\n      context,\n      invitationToken,\n      loginHint,\n      organizationId,\n      passwordResetToken,\n      redirectUri: this.#redirectUri,\n      screenHint: type,\n      state: state ? JSON.stringify(state) : undefined,\n    });\n\n    return url;\n  }\n\n  #getAccessToken() {\n    return memoryStorage.getItem(storageKeys.accessToken) as string | undefined;\n  }\n\n  get #useCookie() {\n    return !this.#devMode;\n  }\n\n  async #onRefresh(authenticationResponse: AuthenticationResponse) {\n    if (this.#onRefreshCallback) {\n      // there's no good reason for client code to access the refresh token\n      const { refreshToken: _refreshToken, ...onRefreshData } =\n        authenticationResponse;\n      this.#onRefreshCallback(onRefreshData);\n    }\n  }\n}\n\nexport async function createClient(\n  clientId: string,\n  options: CreateClientOptions = {},\n) {\n  const client = new Client(clientId, options);\n\n  await client.initialize();\n\n  return client;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}