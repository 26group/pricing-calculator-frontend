{"ast":null,"code":"import _objectSpread from \"/Users/phillip/Development/pricing-calculator/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/Users/phillip/Development/pricing-calculator/frontend/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"user\", \"organization_id\", \"access_token\", \"refresh_token\", \"impersonator\"],\n  _excluded2 = [\"refreshToken\"];\nvar __typeError = msg => {\n  throw TypeError(msg);\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nvar __privateMethod = (obj, member, method) => (__accessCheck(obj, member, \"access private method\"), method);\n\n// src/exceptions/no-client-id-provided.exception.ts\nvar NoClientIdProvidedException = class extends Error {\n  constructor() {\n    super(...arguments);\n    this.status = 500;\n    this.name = \"NoClientIdProvidedException\";\n    this.message = \"Missing Client ID. Pass it to the constructor (createClient(\\\"client_01HXRMBQ9BJ3E7QSTQ9X2PHVB7\\\"))\";\n  }\n};\n\n// src/utils/is-redirect-callback.ts\nfunction isRedirectCallback(redirectUri, searchParams) {\n  const hasCode = searchParams.has(\"code\");\n  if (!hasCode) return false;\n  const {\n    pathname: currentPathName\n  } = window.location;\n  const redirectPathname = new URL(redirectUri).pathname;\n  return currentPathName === redirectPathname || currentPathName === \"\".concat(redirectPathname, \"/\");\n}\n\n// src/utils/memory-storage.ts\nfunction createMemoryStorage() {\n  let _store = {};\n  function setItem(key, value) {\n    _store[key] = value;\n  }\n  function getItem(key) {\n    return _store[key];\n  }\n  function removeItem(key) {\n    delete _store[key];\n  }\n  function reset() {\n    _store = {};\n  }\n  return {\n    setItem,\n    getItem,\n    removeItem,\n    reset\n  };\n}\nvar memoryStorage = createMemoryStorage();\n\n// src/utils/pkce.ts\nasync function createPkceChallenge() {\n  const codeVerifier = createCodeVerifier();\n  const codeChallenge = await createCodeChallenge(codeVerifier);\n  return {\n    codeVerifier,\n    codeChallenge\n  };\n}\nfunction createCodeVerifier() {\n  const randomBytes = crypto.getRandomValues(new Uint32Array(96));\n  return base64urlEncode(randomBytes);\n}\nasync function createCodeChallenge(codeVerifier) {\n  const hashed = await sha256(codeVerifier);\n  return base64urlEncode(hashed);\n}\nfunction base64urlEncode(buffer) {\n  return btoa(Array.from(new Uint8Array(buffer), b => String.fromCharCode(b)).join(\"\")).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n}\nfunction sha256(plain) {\n  const encoder = new TextEncoder();\n  const data = encoder.encode(plain);\n  return crypto.subtle.digest(\"SHA-256\", data);\n}\n\n// src/utils/jwt.ts\nfunction decodeBase64Url(input) {\n  const base64 = input.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  const padding = \"=\".repeat((4 - base64.length % 4) % 4);\n  return atob(base64 + padding);\n}\nfunction decodeJwt(token) {\n  const parts = token.split(\".\");\n  if (parts.length !== 3) {\n    throw new Error(\"Invalid JWT format\");\n  }\n  try {\n    const header = JSON.parse(decodeBase64Url(parts[0]));\n    const payload = JSON.parse(decodeBase64Url(parts[1]));\n    return {\n      header,\n      payload\n    };\n  } catch (error) {\n    throw new Error(\"Failed to decode JWT: \".concat(error instanceof Error ? error.message : String(error)));\n  }\n}\n\n// src/utils/storage-keys.ts\nvar storageKeys = {\n  codeVerifier: \"workos:code-verifier\",\n  user: \"workos:user\",\n  accessToken: \"workos:access-token\",\n  refreshToken: \"workos:refresh-token\",\n  expiresAt: \"workos:expires-at\"\n};\n\n// src/utils/session-data.ts\nfunction getClaims(accessToken) {\n  return decodeJwt(accessToken).payload;\n}\nfunction setSessionData(data) {\n  let {\n    devMode = false\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    user,\n    accessToken,\n    refreshToken\n  } = data;\n  memoryStorage.setItem(storageKeys.user, user);\n  memoryStorage.setItem(storageKeys.accessToken, accessToken);\n  (devMode ? window.localStorage : memoryStorage).setItem(storageKeys.refreshToken, refreshToken);\n  const {\n    exp,\n    iat\n  } = getClaims(accessToken);\n  const expiresIn = exp - iat;\n  const expiresAt = Date.now() + expiresIn * 1e3;\n  memoryStorage.setItem(storageKeys.expiresAt, expiresAt);\n}\nfunction removeSessionData() {\n  let {\n    devMode = false\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  memoryStorage.removeItem(storageKeys.user);\n  memoryStorage.removeItem(storageKeys.accessToken);\n  (devMode ? window.localStorage : memoryStorage).removeItem(storageKeys.refreshToken);\n}\nfunction getRefreshToken() {\n  let {\n    devMode = false\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return (devMode ? window.localStorage : memoryStorage).getItem(storageKeys.refreshToken);\n}\n\n// src/utils/to-query-string.ts\nfunction toQueryString(options) {\n  const searchParams = new URLSearchParams();\n  const keys = Object.keys(options).sort();\n  for (const key of keys) {\n    const value = options[key];\n    if (value) {\n      searchParams.append(key, value);\n    }\n  }\n  return searchParams.toString();\n}\n\n// src/errors.ts\nvar AuthKitError = class extends Error {};\nvar RefreshError = class extends AuthKitError {};\nvar CodeExchangeError = class extends AuthKitError {};\nvar LoginRequiredError = class extends AuthKitError {\n  constructor() {\n    super(...arguments);\n    this.message = \"No access token available\";\n  }\n};\n\n// src/vendor/browser-tabs-lock/processLock.ts\nvar ProcessLocking = class _ProcessLocking {\n  constructor() {\n    this.locked = /* @__PURE__ */new Map();\n    this.addToLocked = (key, toAdd) => {\n      let callbacks = this.locked.get(key);\n      if (callbacks === void 0) {\n        if (toAdd === void 0) {\n          this.locked.set(key, []);\n        } else {\n          this.locked.set(key, [toAdd]);\n        }\n      } else {\n        if (toAdd !== void 0) {\n          callbacks.unshift(toAdd);\n          this.locked.set(key, callbacks);\n        }\n      }\n    };\n    this.isLocked = key => {\n      return this.locked.has(key);\n    };\n    this.lock = key => {\n      return new Promise((resolve, reject) => {\n        if (this.isLocked(key)) {\n          this.addToLocked(key, resolve);\n        } else {\n          this.addToLocked(key);\n          resolve();\n        }\n      });\n    };\n    this.unlock = key => {\n      let callbacks = this.locked.get(key);\n      if (callbacks === void 0 || callbacks.length === 0) {\n        this.locked.delete(key);\n        return;\n      }\n      let toCall = callbacks.pop();\n      this.locked.set(key, callbacks);\n      if (toCall !== void 0) {\n        setTimeout(toCall, 0);\n      }\n    };\n  }\n  static getInstance() {\n    if (_ProcessLocking.instance === void 0) {\n      _ProcessLocking.instance = new _ProcessLocking();\n    }\n    return _ProcessLocking.instance;\n  }\n};\nfunction getLock() {\n  return ProcessLocking.getInstance();\n}\n\n// src/vendor/browser-tabs-lock/index.ts\nvar LOCK_STORAGE_KEY = \"browser-tabs-lock-key\";\nvar DEFAULT_STORAGE_HANDLER = {\n  key: async index => {\n    throw new Error(\"Unsupported\");\n  },\n  getItem: async key => {\n    throw new Error(\"Unsupported\");\n  },\n  clear: async () => {\n    return window.localStorage.clear();\n  },\n  removeItem: async key => {\n    throw new Error(\"Unsupported\");\n  },\n  setItem: async (key, value) => {\n    throw new Error(\"Unsupported\");\n  },\n  keySync: index => {\n    return window.localStorage.key(index);\n  },\n  getItemSync: key => {\n    return window.localStorage.getItem(key);\n  },\n  clearSync: () => {\n    return window.localStorage.clear();\n  },\n  removeItemSync: key => {\n    return window.localStorage.removeItem(key);\n  },\n  setItemSync: (key, value) => {\n    return window.localStorage.setItem(key, value);\n  }\n};\nfunction delay(milliseconds) {\n  return new Promise(resolve => setTimeout(resolve, milliseconds));\n}\nfunction generateRandomString(length) {\n  const CHARS = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz\";\n  let randomstring = \"\";\n  for (let i = 0; i < length; i++) {\n    const INDEX = Math.floor(Math.random() * CHARS.length);\n    randomstring += CHARS[INDEX];\n  }\n  return randomstring;\n}\nfunction getLockId() {\n  return Date.now().toString() + generateRandomString(15);\n}\nvar _SuperTokensLock = class _SuperTokensLock {\n  constructor(storageHandler) {\n    this.acquiredIatSet = /* @__PURE__ */new Set();\n    this.storageHandler = void 0;\n    this.id = getLockId();\n    this.acquireLock = this.acquireLock.bind(this);\n    this.releaseLock = this.releaseLock.bind(this);\n    this.releaseLock__private__ = this.releaseLock__private__.bind(this);\n    this.waitForSomethingToChange = this.waitForSomethingToChange.bind(this);\n    this.refreshLockWhileAcquired = this.refreshLockWhileAcquired.bind(this);\n    this.storageHandler = storageHandler;\n    if (_SuperTokensLock.waiters === void 0) {\n      _SuperTokensLock.waiters = [];\n    }\n  }\n  /**\n   * @async\n   * @memberOf Lock\n   * @function acquireLock\n   * @param {string} lockKey - Key for which the lock is being acquired\n   * @param {number} [timeout=5000] - Maximum time for which the function will wait to acquire the lock\n   * @returns {Promise<boolean>}\n   * @description Will return true if lock is being acquired, else false.\n   *              Also the lock can be acquired for maximum 10 secs\n   */\n  async acquireLock(lockKey) {\n    let timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5e3;\n    let iat = Date.now() + generateRandomString(4);\n    const MAX_TIME = Date.now() + timeout;\n    const STORAGE_KEY = \"\".concat(LOCK_STORAGE_KEY, \"-\").concat(lockKey);\n    const STORAGE = this.storageHandler === void 0 ? DEFAULT_STORAGE_HANDLER : this.storageHandler;\n    while (Date.now() < MAX_TIME) {\n      await delay(30);\n      let lockObj = STORAGE.getItemSync(STORAGE_KEY);\n      if (lockObj === null) {\n        const TIMEOUT_KEY = \"\".concat(this.id, \"-\").concat(lockKey, \"-\").concat(iat);\n        await delay(Math.floor(Math.random() * 25));\n        STORAGE.setItemSync(STORAGE_KEY, JSON.stringify({\n          id: this.id,\n          iat,\n          timeoutKey: TIMEOUT_KEY,\n          timeAcquired: Date.now(),\n          timeRefreshed: Date.now()\n        }));\n        await delay(30);\n        let lockObjPostDelay = STORAGE.getItemSync(STORAGE_KEY);\n        if (lockObjPostDelay !== null) {\n          let parsedLockObjPostDelay = JSON.parse(lockObjPostDelay);\n          if (parsedLockObjPostDelay.id === this.id && parsedLockObjPostDelay.iat === iat) {\n            this.acquiredIatSet.add(iat);\n            this.refreshLockWhileAcquired(STORAGE_KEY, iat);\n            return true;\n          }\n        }\n      } else {\n        _SuperTokensLock.lockCorrector(this.storageHandler === void 0 ? DEFAULT_STORAGE_HANDLER : this.storageHandler);\n        await this.waitForSomethingToChange(MAX_TIME);\n      }\n      iat = Date.now() + generateRandomString(4);\n    }\n    return false;\n  }\n  async refreshLockWhileAcquired(storageKey, iat) {\n    setTimeout(async () => {\n      await getLock().lock(iat);\n      if (!this.acquiredIatSet.has(iat)) {\n        getLock().unlock(iat);\n        return;\n      }\n      const STORAGE = this.storageHandler === void 0 ? DEFAULT_STORAGE_HANDLER : this.storageHandler;\n      let lockObj = STORAGE.getItemSync(storageKey);\n      if (lockObj !== null) {\n        let parsedLockObj = JSON.parse(lockObj);\n        parsedLockObj.timeRefreshed = Date.now();\n        STORAGE.setItemSync(storageKey, JSON.stringify(parsedLockObj));\n        getLock().unlock(iat);\n      } else {\n        getLock().unlock(iat);\n        return;\n      }\n      this.refreshLockWhileAcquired(storageKey, iat);\n    }, 1e3);\n  }\n  async waitForSomethingToChange(MAX_TIME) {\n    await new Promise(resolve => {\n      let resolvedCalled = false;\n      let startedAt = Date.now();\n      const MIN_TIME_TO_WAIT = 50;\n      let removedListeners = false;\n      function stopWaiting() {\n        if (!removedListeners) {\n          window.removeEventListener(\"storage\", stopWaiting);\n          _SuperTokensLock.removeFromWaiting(stopWaiting);\n          clearTimeout(timeOutId);\n          removedListeners = true;\n        }\n        if (!resolvedCalled) {\n          resolvedCalled = true;\n          let timeToWait = MIN_TIME_TO_WAIT - (Date.now() - startedAt);\n          if (timeToWait > 0) {\n            setTimeout(resolve, timeToWait);\n          } else {\n            resolve(null);\n          }\n        }\n      }\n      window.addEventListener(\"storage\", stopWaiting);\n      _SuperTokensLock.addToWaiting(stopWaiting);\n      let timeOutId = setTimeout(stopWaiting, Math.max(0, MAX_TIME - Date.now()));\n    });\n  }\n  static addToWaiting(func) {\n    this.removeFromWaiting(func);\n    if (_SuperTokensLock.waiters === void 0) {\n      return;\n    }\n    _SuperTokensLock.waiters.push(func);\n  }\n  static removeFromWaiting(func) {\n    if (_SuperTokensLock.waiters === void 0) {\n      return;\n    }\n    _SuperTokensLock.waiters = _SuperTokensLock.waiters.filter(i => i !== func);\n  }\n  static notifyWaiters() {\n    if (_SuperTokensLock.waiters === void 0) {\n      return;\n    }\n    let waiters = [..._SuperTokensLock.waiters];\n    waiters.forEach(i => i());\n  }\n  /**\n   * @function releaseLock\n   * @memberOf Lock\n   * @param {string} lockKey - Key for which lock is being released\n   * @returns {void}\n   * @description Release a lock.\n   */\n  async releaseLock(lockKey) {\n    return await this.releaseLock__private__(lockKey);\n  }\n  /**\n   * @function releaseLock\n   * @memberOf Lock\n   * @param {string} lockKey - Key for which lock is being released\n   * @returns {void}\n   * @description Release a lock.\n   */\n  async releaseLock__private__(lockKey) {\n    const STORAGE = this.storageHandler === void 0 ? DEFAULT_STORAGE_HANDLER : this.storageHandler;\n    const STORAGE_KEY = \"\".concat(LOCK_STORAGE_KEY, \"-\").concat(lockKey);\n    let lockObj = STORAGE.getItemSync(STORAGE_KEY);\n    if (lockObj === null) {\n      return;\n    }\n    let parsedlockObj = JSON.parse(lockObj);\n    if (parsedlockObj.id === this.id) {\n      await getLock().lock(parsedlockObj.iat);\n      this.acquiredIatSet.delete(parsedlockObj.iat);\n      STORAGE.removeItemSync(STORAGE_KEY);\n      getLock().unlock(parsedlockObj.iat);\n      _SuperTokensLock.notifyWaiters();\n    }\n  }\n  /**\n   * @function lockCorrector\n   * @returns {void}\n   * @description If a lock is acquired by a tab and the tab is closed before the lock is\n   *              released, this function will release those locks\n   */\n  static lockCorrector(storageHandler) {\n    const MIN_ALLOWED_TIME = Date.now() - 5e3;\n    const STORAGE = storageHandler;\n    const KEYS = [];\n    let currIndex = 0;\n    while (true) {\n      let key = STORAGE.keySync(currIndex);\n      if (key === null) {\n        break;\n      }\n      KEYS.push(key);\n      currIndex++;\n    }\n    let notifyWaiters = false;\n    for (let i = 0; i < KEYS.length; i++) {\n      const LOCK_KEY = KEYS[i];\n      if (LOCK_KEY.includes(LOCK_STORAGE_KEY)) {\n        let lockObj = STORAGE.getItemSync(LOCK_KEY);\n        if (lockObj !== null) {\n          let parsedlockObj = JSON.parse(lockObj);\n          if (parsedlockObj.timeRefreshed === void 0 && parsedlockObj.timeAcquired < MIN_ALLOWED_TIME || parsedlockObj.timeRefreshed !== void 0 && parsedlockObj.timeRefreshed < MIN_ALLOWED_TIME) {\n            STORAGE.removeItemSync(LOCK_KEY);\n            notifyWaiters = true;\n          }\n        }\n      }\n    }\n    if (notifyWaiters) {\n      _SuperTokensLock.notifyWaiters();\n    }\n  }\n};\n_SuperTokensLock.waiters = void 0;\nvar SuperTokensLock = _SuperTokensLock;\n\n// src/utils/locking.ts\nvar DEFAULT_LOCK_TIMEOUT_MS = 1e4;\nfunction withLock(lockName, callback) {\n  let {\n    timeout = DEFAULT_LOCK_TIMEOUT_MS\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  if (!lockName) {\n    throw new TypeError(\"lockName is required and must be a non-empty string.\");\n  }\n  return \"locks\" in navigator ? withNativeLock(lockName, callback, timeout) : withVendorLock(lockName, callback, timeout);\n}\nasync function withNativeLock(lockName, callback, timeout) {\n  try {\n    return await navigator.locks.request(lockName, {\n      signal: AbortSignal.timeout(timeout)\n    }, callback);\n  } catch (error) {\n    if (error instanceof DOMException) {\n      switch (error.name) {\n        case \"AbortError\":\n          throw new LockError(\"AcquisitionTimeoutError\", lockName, \"Native\");\n        case \"InvalidStateError\":\n        case \"NotSupportedError\":\n        case \"SecurityError\":\n      }\n    }\n    throw error;\n  }\n}\nasync function withVendorLock(lockName, callback, timeout) {\n  const lock = new SuperTokensLock();\n  try {\n    if (await lock.acquireLock(lockName, timeout)) {\n      return await callback();\n    } else {\n      throw new LockError(\"AcquisitionTimeoutError\", lockName, \"Vendor\");\n    }\n  } finally {\n    await lock.releaseLock(lockName);\n  }\n}\nvar LockError = class extends Error {\n  constructor(name, lockName, type) {\n    super(\"Lock acquisition timed out for \\\"\".concat(lockName, \"\\\" (\").concat(type, \")\"));\n    this.name = name;\n    this.lockName = lockName;\n  }\n};\n\n// src/serializers/user.serializer.ts\nvar deserializeUser = user => ({\n  object: user.object,\n  id: user.id,\n  email: user.email,\n  emailVerified: user.email_verified,\n  firstName: user.first_name,\n  profilePictureUrl: user.profile_picture_url,\n  lastName: user.last_name,\n  lastSignInAt: user.last_sign_in_at,\n  externalId: user.external_id,\n  createdAt: user.created_at,\n  updatedAt: user.updated_at\n});\n\n// src/serializers/authentication-response.serializer.ts\nvar deserializeAuthenticationResponse = authenticationResponse => {\n  const {\n      user,\n      organization_id,\n      access_token,\n      refresh_token,\n      impersonator\n    } = authenticationResponse,\n    rest = _objectWithoutProperties(authenticationResponse, _excluded);\n  return _objectSpread({\n    user: deserializeUser(user),\n    organizationId: organization_id,\n    accessToken: access_token,\n    refreshToken: refresh_token,\n    impersonator\n  }, rest);\n};\n\n// src/http-client.ts\nvar DEFAULT_HOSTNAME = \"api.workos.com\";\nvar _baseUrl, _clientId, _HttpClient_instances, post_fn;\nvar HttpClient = class {\n  constructor(_ref) {\n    let {\n      clientId,\n      hostname = DEFAULT_HOSTNAME,\n      port,\n      https = true\n    } = _ref;\n    __privateAdd(this, _HttpClient_instances);\n    __privateAdd(this, _baseUrl);\n    __privateAdd(this, _clientId);\n    __privateSet(this, _baseUrl, \"\".concat(https ? \"https\" : \"http\", \"://\").concat(hostname).concat(port ? \":\".concat(port) : \"\"));\n    __privateSet(this, _clientId, clientId);\n  }\n  async authenticateWithRefreshToken(_ref2) {\n    let {\n      refreshToken,\n      organizationId,\n      useCookie\n    } = _ref2;\n    const response = await __privateMethod(this, _HttpClient_instances, post_fn).call(this, \"/user_management/authenticate\", {\n      useCookie,\n      body: _objectSpread(_objectSpread({\n        client_id: __privateGet(this, _clientId),\n        grant_type: \"refresh_token\"\n      }, !useCookie && {\n        refresh_token: refreshToken\n      }), {}, {\n        organization_id: organizationId\n      })\n    });\n    if (response.ok) {\n      const data = await response.json();\n      return deserializeAuthenticationResponse(data);\n    } else {\n      const error = await response.json();\n      throw new RefreshError(error.error_description);\n    }\n  }\n  async authenticateWithCode(_ref3) {\n    let {\n      code,\n      codeVerifier,\n      useCookie\n    } = _ref3;\n    const response = await __privateMethod(this, _HttpClient_instances, post_fn).call(this, \"/user_management/authenticate\", {\n      useCookie,\n      body: {\n        code,\n        client_id: __privateGet(this, _clientId),\n        grant_type: \"authorization_code\",\n        code_verifier: codeVerifier\n      }\n    });\n    if (response.ok) {\n      const data = await response.json();\n      return deserializeAuthenticationResponse(data);\n    }\n    const error = await response.json();\n    throw new CodeExchangeError(error.error_description);\n  }\n  getAuthorizationUrl(_ref4) {\n    let {\n      connectionId,\n      context,\n      domainHint,\n      loginHint,\n      organizationId,\n      provider = \"authkit\",\n      redirectUri,\n      state,\n      screenHint,\n      passwordResetToken,\n      invitationToken,\n      codeChallenge,\n      codeChallengeMethod\n    } = _ref4;\n    if (!provider && !connectionId && !organizationId) {\n      throw new TypeError(\"Incomplete arguments. Need to specify either a 'connectionId', 'organizationId', or 'provider'.\");\n    }\n    if (provider !== \"authkit\" && screenHint) {\n      throw new TypeError(\"'screenHint' is only supported for 'authkit' provider\");\n    }\n    if (context) {\n      console.warn(\"`context` is deprecated. We previously required initiate login endpoints to return the\\n`context` query parameter when getting the authorization URL. This is no longer necessary.\");\n    }\n    const query = toQueryString({\n      connection_id: connectionId,\n      organization_id: organizationId,\n      domain_hint: domainHint,\n      login_hint: loginHint,\n      provider,\n      client_id: __privateGet(this, _clientId),\n      redirect_uri: redirectUri,\n      response_type: \"code\",\n      state,\n      screen_hint: screenHint,\n      invitation_token: invitationToken,\n      password_reset_token: passwordResetToken,\n      code_challenge: codeChallenge,\n      code_challenge_method: codeChallengeMethod\n    });\n    return \"\".concat(__privateGet(this, _baseUrl), \"/user_management/authorize?\").concat(query);\n  }\n  getLogoutUrl(_ref5) {\n    let {\n      sessionId,\n      returnTo\n    } = _ref5;\n    const url = new URL(\"/user_management/sessions/logout\", __privateGet(this, _baseUrl));\n    url.searchParams.set(\"session_id\", sessionId);\n    if (returnTo) {\n      url.searchParams.set(\"return_to\", returnTo);\n    }\n    return url;\n  }\n};\n_baseUrl = new WeakMap();\n_clientId = new WeakMap();\n_HttpClient_instances = new WeakSet();\npost_fn = function (path, _ref6) {\n  let {\n    body,\n    useCookie\n  } = _ref6;\n  return fetch(new URL(path, __privateGet(this, _baseUrl)), _objectSpread(_objectSpread({\n    method: \"POST\"\n  }, useCookie && {\n    credentials: \"include\"\n  }), {}, {\n    headers: {\n      Accept: \"application/json, text/plain, */*\",\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify(body)\n  }));\n};\n\n// src/create-client.ts\nvar ORGANIZATION_ID_SESSION_STORAGE_KEY = \"workos_organization_id\";\nvar REFRESH_LOCK_NAME = \"WORKOS_REFRESH_SESSION\";\nvar _state, _refreshTimer, _httpClient, _redirectUri, _devMode, _onBeforeAutoRefresh, _onRedirectCallback, _onRefreshCallback, _onRefreshFailure, _refreshBufferInterval, _Client_instances, handleCallback_fn, scheduleAutomaticRefresh_fn, refreshSession_fn, doRefresh_fn, shouldRefresh_fn, getAuthorizationUrl_fn, getAccessToken_fn, useCookie_get, onRefresh_fn;\nvar Client = class {\n  constructor(clientId) {\n    let {\n      apiHostname: hostname,\n      https,\n      port,\n      redirectUri = window.origin,\n      devMode = location.hostname === \"localhost\" || location.hostname === \"127.0.0.1\",\n      // refresh if this is true\n      onBeforeAutoRefresh = () => {\n        return !document.hidden;\n      },\n      onRedirectCallback = _ => {},\n      onRefresh,\n      onRefreshFailure,\n      refreshBufferInterval = 10\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    __privateAdd(this, _Client_instances);\n    __privateAdd(this, _state);\n    __privateAdd(this, _refreshTimer);\n    __privateAdd(this, _httpClient);\n    __privateAdd(this, _redirectUri);\n    __privateAdd(this, _devMode);\n    __privateAdd(this, _onBeforeAutoRefresh);\n    __privateAdd(this, _onRedirectCallback);\n    __privateAdd(this, _onRefreshCallback);\n    __privateAdd(this, _onRefreshFailure);\n    __privateAdd(this, _refreshBufferInterval);\n    if (!clientId) {\n      throw new NoClientIdProvidedException();\n    }\n    __privateSet(this, _httpClient, new HttpClient({\n      clientId,\n      hostname,\n      port,\n      https\n    }));\n    __privateSet(this, _devMode, devMode);\n    __privateSet(this, _redirectUri, redirectUri);\n    __privateSet(this, _state, {\n      tag: \"INITIAL\"\n    });\n    __privateSet(this, _onBeforeAutoRefresh, onBeforeAutoRefresh);\n    __privateSet(this, _onRedirectCallback, onRedirectCallback);\n    __privateSet(this, _onRefreshCallback, onRefresh);\n    __privateSet(this, _onRefreshFailure, onRefreshFailure);\n    __privateSet(this, _refreshBufferInterval, refreshBufferInterval);\n  }\n  async initialize() {\n    if (__privateGet(this, _state).tag !== \"INITIAL\") {\n      return;\n    }\n    const searchParams = new URLSearchParams(window.location.search);\n    if (isRedirectCallback(__privateGet(this, _redirectUri), searchParams)) {\n      await __privateMethod(this, _Client_instances, handleCallback_fn).call(this);\n    } else if (document.cookie.includes(\"workos-has-session=\") || getRefreshToken({\n      devMode: __privateGet(this, _devMode)\n    })) {\n      try {\n        await __privateMethod(this, _Client_instances, refreshSession_fn).call(this);\n        __privateMethod(this, _Client_instances, scheduleAutomaticRefresh_fn).call(this);\n      } catch (_unused) {}\n    }\n  }\n  async getSignInUrl() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const url = await __privateMethod(this, _Client_instances, getAuthorizationUrl_fn).call(this, _objectSpread(_objectSpread({}, opts), {}, {\n      type: \"sign-in\"\n    }));\n    return url;\n  }\n  async getSignUpUrl() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const url = await __privateMethod(this, _Client_instances, getAuthorizationUrl_fn).call(this, _objectSpread(_objectSpread({}, opts), {}, {\n      type: \"sign-up\"\n    }));\n    return url;\n  }\n  async signIn() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const url = await __privateMethod(this, _Client_instances, getAuthorizationUrl_fn).call(this, _objectSpread(_objectSpread({}, opts), {}, {\n      type: \"sign-in\"\n    }));\n    window.location.assign(url);\n  }\n  async signUp() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const url = await __privateMethod(this, _Client_instances, getAuthorizationUrl_fn).call(this, _objectSpread(_objectSpread({}, opts), {}, {\n      type: \"sign-up\"\n    }));\n    window.location.assign(url);\n  }\n  signOut() {\n    var _options$navigate;\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      navigate: true\n    };\n    const navigate = (_options$navigate = options.navigate) !== null && _options$navigate !== void 0 ? _options$navigate : true;\n    const accessToken = memoryStorage.getItem(storageKeys.accessToken);\n    if (typeof accessToken !== \"string\") return;\n    const {\n      sid: sessionId\n    } = getClaims(accessToken);\n    const url = __privateGet(this, _httpClient).getLogoutUrl({\n      sessionId,\n      returnTo: options === null || options === void 0 ? void 0 : options.returnTo\n    });\n    if (url) {\n      removeSessionData({\n        devMode: __privateGet(this, _devMode)\n      });\n      if (navigate) {\n        window.location.assign(url);\n      } else {\n        return new Promise(async resolve => {\n          fetch(url, {\n            mode: \"no-cors\",\n            credentials: \"include\"\n          }).catch(error => {\n            console.warn(\"AuthKit: Failed to send logout request\", error);\n          }).finally(resolve);\n        });\n      }\n    }\n  }\n  async getAccessToken(options) {\n    if (options !== null && options !== void 0 && options.forceRefresh || __privateMethod(this, _Client_instances, shouldRefresh_fn).call(this)) {\n      try {\n        await __privateMethod(this, _Client_instances, refreshSession_fn).call(this);\n      } catch (err) {\n        if (err instanceof RefreshError) {\n          throw new LoginRequiredError();\n        } else {\n          throw err;\n        }\n      }\n    }\n    const accessToken = __privateMethod(this, _Client_instances, getAccessToken_fn).call(this);\n    if (!accessToken) {\n      throw new LoginRequiredError();\n    }\n    return accessToken;\n  }\n  getUser() {\n    const user = memoryStorage.getItem(storageKeys.user);\n    return user ? user : null;\n  }\n  dispose() {\n    clearTimeout(__privateGet(this, _refreshTimer));\n    memoryStorage.reset();\n  }\n  /**\n   * Switches to the requested organization.\n   *\n   * Redirects to the hosted login page for the given organization if the\n   * switch is unsuccessful.\n   */\n  async switchToOrganization(_ref7) {\n    let {\n      organizationId,\n      signInOpts = {}\n    } = _ref7;\n    try {\n      await __privateMethod(this, _Client_instances, refreshSession_fn).call(this, {\n        organizationId\n      });\n    } catch (error) {\n      if (error instanceof RefreshError) {\n        this.signIn(_objectSpread(_objectSpread({}, signInOpts), {}, {\n          organizationId\n        }));\n      } else {\n        throw error;\n      }\n    }\n  }\n};\n_state = new WeakMap();\n_refreshTimer = new WeakMap();\n_httpClient = new WeakMap();\n_redirectUri = new WeakMap();\n_devMode = new WeakMap();\n_onBeforeAutoRefresh = new WeakMap();\n_onRedirectCallback = new WeakMap();\n_onRefreshCallback = new WeakMap();\n_onRefreshFailure = new WeakMap();\n_refreshBufferInterval = new WeakMap();\n_Client_instances = new WeakSet();\nhandleCallback_fn = async function () {\n  if (__privateGet(this, _state).tag !== \"INITIAL\") {\n    return;\n  }\n  const url = new URL(window.location.href);\n  const code = url.searchParams.get(\"code\");\n  const stateParam = url.searchParams.get(\"state\");\n  const state = stateParam ? JSON.parse(stateParam) : void 0;\n  const codeVerifier = window.sessionStorage.getItem(storageKeys.codeVerifier);\n  if (code) {\n    if (codeVerifier) {\n      try {\n        __privateSet(this, _state, {\n          tag: \"AUTHENTICATING\",\n          response: __privateGet(this, _httpClient).authenticateWithCode({\n            code,\n            codeVerifier,\n            useCookie: __privateGet(this, _Client_instances, useCookie_get)\n          })\n        });\n        const authenticationResponse = await __privateGet(this, _state).response;\n        if (authenticationResponse) {\n          __privateSet(this, _state, {\n            tag: \"AUTHENTICATED\"\n          });\n          __privateMethod(this, _Client_instances, scheduleAutomaticRefresh_fn).call(this);\n          setSessionData(authenticationResponse, {\n            devMode: __privateGet(this, _devMode)\n          });\n          __privateMethod(this, _Client_instances, onRefresh_fn).call(this, authenticationResponse);\n          __privateGet(this, _onRedirectCallback).call(this, _objectSpread({\n            state\n          }, authenticationResponse));\n        }\n      } catch (error) {\n        __privateSet(this, _state, {\n          tag: \"ERROR\"\n        });\n        console.error(error);\n      }\n    } else {\n      __privateSet(this, _state, {\n        tag: \"ERROR\"\n      });\n      console.error(\"Couldn't exchange code.\\n\\nAn authorization_code was supplied for a login which did not originate at the application. This could happen for various reasons:\\n\\n* This could have been an attempted Login CSRF attack. You were not affected.\\n* The developer may not have configured a Login Initiation endpoint.\");\n    }\n  }\n  const cleanUrl = new URL(window.location.toString());\n  cleanUrl.search = \"\";\n  window.sessionStorage.removeItem(storageKeys.codeVerifier);\n  window.history.replaceState({}, \"\", cleanUrl);\n};\nscheduleAutomaticRefresh_fn = async function () {\n  __privateSet(this, _refreshTimer, setTimeout(() => {\n    if (__privateMethod(this, _Client_instances, shouldRefresh_fn).call(this) && __privateGet(this, _onBeforeAutoRefresh).call(this)) {\n      __privateMethod(this, _Client_instances, refreshSession_fn).call(this).catch(e => {\n        console.debug(e);\n      }).finally(() => __privateMethod(this, _Client_instances, scheduleAutomaticRefresh_fn).call(this));\n    } else {\n      __privateMethod(this, _Client_instances, scheduleAutomaticRefresh_fn).call(this);\n    }\n  }, 1e3));\n};\nrefreshSession_fn = async function () {\n  let {\n    organizationId\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  if (__privateGet(this, _state).tag === \"AUTHENTICATING\") {\n    await __privateGet(this, _state).response;\n    return;\n  }\n  const beginningState = __privateGet(this, _state);\n  __privateSet(this, _state, {\n    tag: \"AUTHENTICATING\",\n    response: __privateMethod(this, _Client_instances, doRefresh_fn).call(this, {\n      organizationId,\n      beginningState\n    })\n  });\n  await __privateGet(this, _state).response;\n};\ndoRefresh_fn = async function (_ref8) {\n  let {\n    organizationId,\n    beginningState\n  } = _ref8;\n  try {\n    return await withLock(REFRESH_LOCK_NAME, async () => {\n      if (organizationId) {\n        sessionStorage.setItem(ORGANIZATION_ID_SESSION_STORAGE_KEY, organizationId);\n      } else {\n        const accessToken = __privateMethod(this, _Client_instances, getAccessToken_fn).call(this);\n        if (accessToken) {\n          var _getClaims;\n          organizationId = (_getClaims = getClaims(accessToken)) === null || _getClaims === void 0 ? void 0 : _getClaims.org_id;\n        } else {\n          var _sessionStorage$getIt;\n          organizationId = (_sessionStorage$getIt = sessionStorage.getItem(ORGANIZATION_ID_SESSION_STORAGE_KEY)) !== null && _sessionStorage$getIt !== void 0 ? _sessionStorage$getIt : void 0;\n        }\n      }\n      const authenticationResponse = await __privateGet(this, _httpClient).authenticateWithRefreshToken({\n        refreshToken: getRefreshToken({\n          devMode: __privateGet(this, _devMode)\n        }),\n        organizationId,\n        useCookie: __privateGet(this, _Client_instances, useCookie_get)\n      });\n      __privateSet(this, _state, {\n        tag: \"AUTHENTICATED\"\n      });\n      setSessionData(authenticationResponse, {\n        devMode: __privateGet(this, _devMode)\n      });\n      __privateMethod(this, _Client_instances, onRefresh_fn).call(this, authenticationResponse);\n      return authenticationResponse;\n    });\n  } catch (error) {\n    if (error instanceof LockError && error.name === \"AcquisitionTimeoutError\") {\n      console.warn(\"Couldn't acquire refresh lock.\");\n      __privateSet(this, _state, beginningState);\n      throw error;\n    }\n    if (beginningState.tag !== \"INITIAL\") {\n      console.debug(error);\n    }\n    if (error instanceof RefreshError) {\n      removeSessionData({\n        devMode: __privateGet(this, _devMode)\n      });\n      beginningState.tag !== \"INITIAL\" && __privateGet(this, _onRefreshFailure) && __privateGet(this, _onRefreshFailure).call(this, {\n        signIn: this.signIn.bind(this)\n      });\n      __privateSet(this, _state, {\n        tag: \"ERROR\"\n      });\n    } else {\n      __privateSet(this, _state, {\n        tag: \"AUTHENTICATED\"\n      });\n    }\n    throw error;\n  }\n};\nshouldRefresh_fn = function () {\n  switch (__privateGet(this, _state).tag) {\n    case \"INITIAL\":\n    case \"AUTHENTICATING\":\n      return true;\n    case \"ERROR\":\n      return false;\n    case \"AUTHENTICATED\":\n      const accessToken = memoryStorage.getItem(storageKeys.accessToken);\n      const expiresAt = memoryStorage.getItem(storageKeys.expiresAt);\n      if (!accessToken || !expiresAt) {\n        return true;\n      }\n      const tokenRefreshBufferInSeconds = __privateGet(this, _refreshBufferInterval) * 1e3;\n      const refreshTime = expiresAt - tokenRefreshBufferInSeconds;\n      return refreshTime < Date.now();\n  }\n};\ngetAuthorizationUrl_fn = async function (_ref9) {\n  let {\n    context,\n    invitationToken,\n    loginHint,\n    organizationId,\n    passwordResetToken,\n    state,\n    type\n  } = _ref9;\n  const {\n    codeVerifier,\n    codeChallenge\n  } = await createPkceChallenge();\n  window.sessionStorage.setItem(storageKeys.codeVerifier, codeVerifier);\n  const url = __privateGet(this, _httpClient).getAuthorizationUrl({\n    codeChallenge,\n    codeChallengeMethod: \"S256\",\n    context,\n    invitationToken,\n    loginHint,\n    organizationId,\n    passwordResetToken,\n    redirectUri: __privateGet(this, _redirectUri),\n    screenHint: type,\n    state: state ? JSON.stringify(state) : void 0\n  });\n  return url;\n};\ngetAccessToken_fn = function () {\n  return memoryStorage.getItem(storageKeys.accessToken);\n};\nuseCookie_get = function () {\n  return !__privateGet(this, _devMode);\n};\nonRefresh_fn = async function (authenticationResponse) {\n  if (__privateGet(this, _onRefreshCallback)) {\n    const {\n        refreshToken: _refreshToken\n      } = authenticationResponse,\n      onRefreshData = _objectWithoutProperties(authenticationResponse, _excluded2);\n    __privateGet(this, _onRefreshCallback).call(this, onRefreshData);\n  }\n};\nasync function createClient(clientId) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const client = new Client(clientId, options);\n  await client.initialize();\n  return client;\n}\nexport { AuthKitError, LoginRequiredError, createClient, getClaims };","map":{"version":3,"names":["NoClientIdProvidedException","Error","constructor","arguments","status","name","message","isRedirectCallback","redirectUri","searchParams","hasCode","has","pathname","currentPathName","window","location","redirectPathname","URL","concat","createMemoryStorage","_store","setItem","key","value","getItem","removeItem","reset","memoryStorage","createPkceChallenge","codeVerifier","createCodeVerifier","codeChallenge","createCodeChallenge","randomBytes","crypto","getRandomValues","Uint32Array","base64urlEncode","hashed","sha256","buffer","btoa","Array","from","Uint8Array","b","String","fromCharCode","join","replace","plain","encoder","TextEncoder","data","encode","subtle","digest","decodeBase64Url","input","base64","padding","repeat","length","atob","decodeJwt","token","parts","split","header","JSON","parse","payload","error","storageKeys","user","accessToken","refreshToken","expiresAt","getClaims","setSessionData","devMode","undefined","localStorage","exp","iat","expiresIn","Date","now","removeSessionData","getRefreshToken","toQueryString","options","URLSearchParams","keys","Object","sort","append","toString","AuthKitError","RefreshError","CodeExchangeError","LoginRequiredError","ProcessLocking","_ProcessLocking","locked","Map","addToLocked","toAdd","callbacks","get","set","unshift","isLocked","lock","Promise","resolve","reject","unlock","delete","toCall","pop","setTimeout","getInstance","instance","getLock","LOCK_STORAGE_KEY","DEFAULT_STORAGE_HANDLER","index","clear","keySync","getItemSync","clearSync","removeItemSync","setItemSync","delay","milliseconds","generateRandomString","CHARS","randomstring","i","INDEX","Math","floor","random","getLockId","_SuperTokensLock","storageHandler","acquiredIatSet","Set","id","acquireLock","bind","releaseLock","releaseLock__private__","waitForSomethingToChange","refreshLockWhileAcquired","waiters","lockKey","timeout","MAX_TIME","STORAGE_KEY","STORAGE","lockObj","TIMEOUT_KEY","stringify","timeoutKey","timeAcquired","timeRefreshed","lockObjPostDelay","parsedLockObjPostDelay","add","lockCorrector","storageKey","parsedLockObj","resolvedCalled","startedAt","MIN_TIME_TO_WAIT","removedListeners","stopWaiting","removeEventListener","removeFromWaiting","clearTimeout","timeOutId","timeToWait","addEventListener","addToWaiting","max","func","push","filter","notifyWaiters","forEach","parsedlockObj","MIN_ALLOWED_TIME","KEYS","currIndex","LOCK_KEY","includes","SuperTokensLock","DEFAULT_LOCK_TIMEOUT_MS","withLock","lockName","callback","TypeError","navigator","withNativeLock","withVendorLock","locks","request","signal","AbortSignal","DOMException","LockError","type","deserializeUser","object","email","emailVerified","email_verified","firstName","first_name","profilePictureUrl","profile_picture_url","lastName","last_name","lastSignInAt","last_sign_in_at","externalId","external_id","createdAt","created_at","updatedAt","updated_at","deserializeAuthenticationResponse","authenticationResponse","organization_id","access_token","refresh_token","impersonator","rest","_objectWithoutProperties","_excluded","_objectSpread","organizationId","DEFAULT_HOSTNAME","_baseUrl","_clientId","_HttpClient_instances","post_fn","HttpClient","_ref","clientId","hostname","port","https","__privateAdd","__privateSet","authenticateWithRefreshToken","_ref2","useCookie","response","__privateMethod","call","body","client_id","__privateGet","grant_type","ok","json","error_description","authenticateWithCode","_ref3","code","code_verifier","getAuthorizationUrl","_ref4","connectionId","context","domainHint","loginHint","provider","state","screenHint","passwordResetToken","invitationToken","codeChallengeMethod","console","warn","query","connection_id","domain_hint","login_hint","redirect_uri","response_type","screen_hint","invitation_token","password_reset_token","code_challenge","code_challenge_method","getLogoutUrl","_ref5","sessionId","returnTo","url","WeakMap","WeakSet","path","_ref6","fetch","method","credentials","headers","Accept","ORGANIZATION_ID_SESSION_STORAGE_KEY","REFRESH_LOCK_NAME","_state","_refreshTimer","_httpClient","_redirectUri","_devMode","_onBeforeAutoRefresh","_onRedirectCallback","_onRefreshCallback","_onRefreshFailure","_refreshBufferInterval","_Client_instances","handleCallback_fn","scheduleAutomaticRefresh_fn","refreshSession_fn","doRefresh_fn","shouldRefresh_fn","getAuthorizationUrl_fn","getAccessToken_fn","useCookie_get","onRefresh_fn","Client","apiHostname","origin","onBeforeAutoRefresh","document","hidden","onRedirectCallback","_","onRefresh","onRefreshFailure","refreshBufferInterval","tag","initialize","search","cookie","_unused","getSignInUrl","opts","getSignUpUrl","signIn","assign","signUp","signOut","_options$navigate","navigate","sid","mode","catch","finally","getAccessToken","forceRefresh","err","getUser","dispose","switchToOrganization","_ref7","signInOpts","href","stateParam","sessionStorage","cleanUrl","history","replaceState","e","debug","beginningState","_ref8","_getClaims","org_id","_sessionStorage$getIt","tokenRefreshBufferInSeconds","refreshTime","_ref9","_refreshToken","onRefreshData","_excluded2","createClient","client"],"sources":["/Users/phillip/Development/pricing-calculator/frontend/node_modules/@workos-inc/authkit-js/src/exceptions/no-client-id-provided.exception.ts","/Users/phillip/Development/pricing-calculator/frontend/node_modules/@workos-inc/authkit-js/src/utils/is-redirect-callback.ts","/Users/phillip/Development/pricing-calculator/frontend/node_modules/@workos-inc/authkit-js/src/utils/memory-storage.ts","/Users/phillip/Development/pricing-calculator/frontend/node_modules/@workos-inc/authkit-js/src/utils/pkce.ts","/Users/phillip/Development/pricing-calculator/frontend/node_modules/@workos-inc/authkit-js/src/utils/jwt.ts","/Users/phillip/Development/pricing-calculator/frontend/node_modules/@workos-inc/authkit-js/src/utils/storage-keys.ts","/Users/phillip/Development/pricing-calculator/frontend/node_modules/@workos-inc/authkit-js/src/utils/session-data.ts","/Users/phillip/Development/pricing-calculator/frontend/node_modules/@workos-inc/authkit-js/src/utils/to-query-string.ts","/Users/phillip/Development/pricing-calculator/frontend/node_modules/@workos-inc/authkit-js/src/errors.ts","/Users/phillip/Development/pricing-calculator/frontend/node_modules/@workos-inc/authkit-js/src/vendor/browser-tabs-lock/processLock.ts","/Users/phillip/Development/pricing-calculator/frontend/node_modules/@workos-inc/authkit-js/src/vendor/browser-tabs-lock/index.ts","/Users/phillip/Development/pricing-calculator/frontend/node_modules/@workos-inc/authkit-js/src/utils/locking.ts","/Users/phillip/Development/pricing-calculator/frontend/node_modules/@workos-inc/authkit-js/src/serializers/user.serializer.ts","/Users/phillip/Development/pricing-calculator/frontend/node_modules/@workos-inc/authkit-js/src/serializers/authentication-response.serializer.ts","/Users/phillip/Development/pricing-calculator/frontend/node_modules/@workos-inc/authkit-js/src/http-client.ts","/Users/phillip/Development/pricing-calculator/frontend/node_modules/@workos-inc/authkit-js/src/create-client.ts"],"sourcesContent":["export class NoClientIdProvidedException extends Error {\n  readonly status: number = 500;\n  readonly name: string = \"NoClientIdProvidedException\";\n  readonly message: string = `Missing Client ID. Pass it to the constructor (createClient(\"client_01HXRMBQ9BJ3E7QSTQ9X2PHVB7\"))`;\n}\n","export function isRedirectCallback(\n  redirectUri: string,\n  searchParams: URLSearchParams,\n) {\n  const hasCode = searchParams.has(\"code\");\n  if (!hasCode) return false;\n\n  const { pathname: currentPathName } = window.location;\n  const redirectPathname = new URL(redirectUri).pathname;\n  return (\n    currentPathName === redirectPathname ||\n    currentPathName === `${redirectPathname}/`\n  );\n}\n","function createMemoryStorage() {\n  let _store: { [key: string]: unknown } = {};\n\n  function setItem(key: string, value: unknown): void {\n    _store[key] = value;\n  }\n\n  function getItem(key: string): unknown {\n    return _store[key];\n  }\n\n  function removeItem(key: string): void {\n    delete _store[key];\n  }\n\n  function reset(): void {\n    _store = {};\n  }\n\n  return {\n    setItem,\n    getItem,\n    removeItem,\n    reset,\n  };\n}\n\nconst memoryStorage = createMemoryStorage();\n\nexport { memoryStorage };\n","export async function createPkceChallenge() {\n  const codeVerifier = createCodeVerifier();\n  const codeChallenge = await createCodeChallenge(codeVerifier);\n\n  return { codeVerifier, codeChallenge };\n}\n\nfunction createCodeVerifier() {\n  const randomBytes = crypto.getRandomValues(new Uint32Array(96));\n  return base64urlEncode(randomBytes);\n}\n\nasync function createCodeChallenge(codeVerifier: string) {\n  const hashed = await sha256(codeVerifier);\n  return base64urlEncode(hashed);\n}\n\nfunction base64urlEncode(buffer: ArrayBuffer): string {\n  return btoa(\n    Array.from(new Uint8Array(buffer), (b) => String.fromCharCode(b)).join(\"\"),\n  )\n    .replace(/\\+/g, \"-\")\n    .replace(/\\//g, \"_\")\n    .replace(/=+$/, \"\");\n}\n\nfunction sha256(plain: string): Promise<ArrayBuffer> {\n  const encoder = new TextEncoder();\n  const data = encoder.encode(plain);\n  return crypto.subtle.digest(\"SHA-256\", data);\n}\n","import { JWTHeader, JWTPayload } from \"../interfaces/jwt.interface\";\n\n/**\n * Decodes a base64url encoded string\n * @param input The base64url string to decode\n * @returns The decoded string\n */\nfunction decodeBase64Url(input: string): string {\n  const base64 = input.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  const padding = \"=\".repeat((4 - (base64.length % 4)) % 4);\n  return atob(base64 + padding);\n}\n\n/**\n * Decodes a JWT token and returns its header and payload\n * @param token The JWT token to decode\n * @return An object containing the decoded header and payload\n * @throws Error if the token is not in a valid JWT format or if decoding fails\n */\n// should replace this with jose if we ever need to verify the JWT\nexport function decodeJwt<T = {}>(\n  token: string,\n): {\n  header: JWTHeader;\n  payload: JWTPayload & T;\n} {\n  const parts = token.split(\".\");\n\n  if (parts.length !== 3) {\n    throw new Error(\"Invalid JWT format\");\n  }\n\n  try {\n    const header = JSON.parse(decodeBase64Url(parts[0])) as JWTHeader;\n    const payload = JSON.parse(decodeBase64Url(parts[1])) as JWTPayload & T;\n\n    return { header, payload };\n  } catch (error) {\n    throw new Error(\n      `Failed to decode JWT: ${error instanceof Error ? error.message : String(error)}`,\n    );\n  }\n}\n","export const storageKeys = {\n  codeVerifier: \"workos:code-verifier\",\n  user: \"workos:user\",\n  accessToken: \"workos:access-token\",\n  refreshToken: \"workos:refresh-token\",\n  expiresAt: \"workos:expires-at\",\n} as const;\n","import { AuthenticationResponse, JWTPayload } from \"../interfaces\";\nimport { decodeJwt } from \"./jwt\";\nimport { memoryStorage } from \"./memory-storage\";\nimport { storageKeys } from \"./storage-keys\";\n\n/**\n * Retrieves the claims from a JWT access token.\n * @param accessToken - The JWT access token to decode.\n * @returns The decoded JWT payload, which includes the claims.\n */\nexport function getClaims<T = {}>(accessToken: string): JWTPayload & T {\n  return decodeJwt<T>(accessToken).payload;\n}\n\nexport function setSessionData(\n  data: AuthenticationResponse,\n  { devMode = false } = {},\n) {\n  const { user, accessToken, refreshToken } = data;\n  memoryStorage.setItem(storageKeys.user, user);\n  memoryStorage.setItem(storageKeys.accessToken, accessToken);\n  (devMode ? window.localStorage : memoryStorage).setItem(\n    storageKeys.refreshToken,\n    refreshToken,\n  );\n\n  // compute a local time version of expires at (should avoid issues with slightly-wrong clocks)\n  const { exp, iat } = getClaims(accessToken);\n  const expiresIn = exp - iat;\n  const expiresAt = Date.now() + expiresIn * 1000;\n  memoryStorage.setItem(storageKeys.expiresAt, expiresAt);\n}\n\nexport function removeSessionData({ devMode = false } = {}) {\n  memoryStorage.removeItem(storageKeys.user);\n  memoryStorage.removeItem(storageKeys.accessToken);\n  (devMode ? window.localStorage : memoryStorage).removeItem(\n    storageKeys.refreshToken,\n  );\n}\n\nexport function getRefreshToken({ devMode = false } = {}) {\n  return (devMode ? window.localStorage : memoryStorage).getItem(\n    storageKeys.refreshToken,\n  ) as string | undefined;\n}\n","export function toQueryString(\n  options: Record<string, string | undefined>,\n): string {\n  const searchParams = new URLSearchParams();\n  const keys = Object.keys(options).sort();\n\n  for (const key of keys) {\n    const value = options[key];\n\n    if (value) {\n      searchParams.append(key, value);\n    }\n  }\n\n  return searchParams.toString();\n}\n","export class AuthKitError extends Error {}\nexport class RefreshError extends AuthKitError {}\nexport class CodeExchangeError extends AuthKitError {}\nexport class LoginRequiredError extends AuthKitError {\n  readonly message: string = \"No access token available\";\n}\n","declare let setTimeout: any;\nclass ProcessLocking {\n    static instance: undefined | ProcessLocking;\n    private locked: Map<string, (() => void)[]> = new Map<string, (() => void)[]>();\n\n\n    static getInstance() {\n        if (ProcessLocking.instance === undefined) {\n            ProcessLocking.instance = new ProcessLocking();\n        }\n        return ProcessLocking.instance;\n    }\n\n    private addToLocked = (key: string, toAdd?: () => void) => {\n        let callbacks = this.locked.get(key);\n        if (callbacks === undefined) {\n            if (toAdd === undefined) {\n                this.locked.set(key, []);\n            } else {\n                this.locked.set(key, [toAdd]);\n            }\n        } else {\n            if (toAdd !== undefined) {\n                callbacks.unshift(toAdd);\n                this.locked.set(key, callbacks);\n            }\n        }\n    }\n\n    isLocked = (key: string): boolean => {\n        return this.locked.has(key);\n    }\n\n    lock = (key: string): Promise<void> => {\n        return new Promise<void>((resolve, reject) => {\n            if (this.isLocked(key)) {\n                this.addToLocked(key, resolve);\n            } else {\n                this.addToLocked(key);\n                resolve();\n            }\n        });\n    }\n\n    unlock = (key: string) => {\n        let callbacks = this.locked.get(key);\n        if (callbacks === undefined || callbacks.length === 0) {\n            this.locked.delete(key);\n            return;\n        }\n        let toCall = callbacks.pop();\n        this.locked.set(key, callbacks);\n        if (toCall !== undefined) {\n            setTimeout(toCall, 0);\n        }\n    }\n}\n\nexport default function getLock(): ProcessLocking {\n    return ProcessLocking.getInstance();\n}","import getProcessLock from './processLock';\n\n/**\n * @author: SuperTokens (https://github.com/supertokens)\n * This library was created as a part of a larger project, SuperTokens(https://supertokens.io) - the best session management solution.\n * You can also check out our other projects on https://github.com/supertokens\n * \n * To contribute to this package visit https://github.com/supertokens/browser-tabs-lock\n * If you face any problems you can file an issue on https://github.com/supertokens/browser-tabs-lock/issues\n * \n * If you have any questions or if you just want to say hi visit https://supertokens.io/discord\n */\n\n\n/**\n * @constant\n * @type {string}\n * @default\n * @description All the locks taken by this package will have this as prefix\n*/\nconst LOCK_STORAGE_KEY = 'browser-tabs-lock-key';\n\ndeclare let setTimeout: any;\ndeclare let window: any;\ndeclare let clearTimeout: any;\n\nexport type StorageHandler = {\n    key: (index: number) => Promise<string | null>;\n    getItem: (key: string) => Promise<string | null>;\n    clear: () => Promise<void>;\n    removeItem: (key: string) => Promise<void>;\n    setItem: (key: string, value: string) => Promise<void>;\n    /**\n     * Sync versions of the storage functions\n     */\n    keySync: (index: number) => string | null;\n    getItemSync: (key: string) => string | null;\n    clearSync: () => void;\n    removeItemSync: (key: string) => void;\n    setItemSync: (key: string, value: string) => void;\n};\n\nconst DEFAULT_STORAGE_HANDLER: StorageHandler = {\n    key: async (index: number) => {\n        throw new Error(\"Unsupported\");\n    },\n    getItem: async (key: string) => {\n        throw new Error(\"Unsupported\");\n    },\n    clear: async () => {\n        return window.localStorage.clear();\n    },\n    removeItem: async (key: string) => {\n        throw new Error(\"Unsupported\");\n    },\n    setItem: async (key: string, value: string) => {\n        throw new Error(\"Unsupported\");\n    },\n    keySync: (index: number) => {\n        return window.localStorage.key(index);\n    },\n    getItemSync: (key: string) => {\n        return window.localStorage.getItem(key);\n    },\n    clearSync: () => {\n        return window.localStorage.clear();\n    },\n    removeItemSync: (key: string) => {\n        return window.localStorage.removeItem(key);\n    },\n    setItemSync: (key: string, value: string) => {\n        return window.localStorage.setItem(key, value);\n    },\n\n}\n\n/**\n * @function delay\n * @param {number} milliseconds - How long the delay should be in terms of milliseconds\n * @returns {Promise<void>} \n */\nfunction delay(milliseconds: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, milliseconds));\n}\n\n/**\n * @function generateRandomString\n * @params {number} length - How long the random string should be\n * @returns {string}\n * @description returns random string whose length is equal to the length passed as parameter\n */\nfunction generateRandomString(length: number): string {\n    const CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz';\n    let randomstring = '';\n    for (let i = 0; i < length; i++) {\n        const INDEX = Math.floor(Math.random() * CHARS.length);\n        randomstring += CHARS[INDEX];\n    }\n    return randomstring;\n}\n\n/**\n * @function getLockId\n * @returns {string}\n * @description Generates an id which will be unique for the browser tab\n */\nfunction getLockId(): string {\n    return Date.now().toString() + generateRandomString(15)\n}\n\nexport default class SuperTokensLock {\n    private static waiters: Array<any> | undefined = undefined;\n    private id: string;\n    private acquiredIatSet: Set<String> = new Set<String>();\n    private storageHandler: StorageHandler | undefined = undefined;\n\n    constructor(storageHandler?: StorageHandler) {\n        this.id = getLockId();\n        this.acquireLock = this.acquireLock.bind(this);\n        this.releaseLock = this.releaseLock.bind(this);\n        this.releaseLock__private__ = this.releaseLock__private__.bind(this);\n        this.waitForSomethingToChange = this.waitForSomethingToChange.bind(this);\n        this.refreshLockWhileAcquired = this.refreshLockWhileAcquired.bind(this);\n        this.storageHandler = storageHandler;\n        if (SuperTokensLock.waiters === undefined) {\n            SuperTokensLock.waiters = [];\n        }\n    }\n\n    /**\n     * @async\n     * @memberOf Lock\n     * @function acquireLock\n     * @param {string} lockKey - Key for which the lock is being acquired\n     * @param {number} [timeout=5000] - Maximum time for which the function will wait to acquire the lock\n     * @returns {Promise<boolean>}\n     * @description Will return true if lock is being acquired, else false.\n     *              Also the lock can be acquired for maximum 10 secs\n     */\n    async acquireLock(lockKey: string, timeout: number = 5000) {\n        let iat = Date.now() + generateRandomString(4);\n        const MAX_TIME = Date.now() + timeout;\n        const STORAGE_KEY = `${LOCK_STORAGE_KEY}-${lockKey}`;\n        const STORAGE: StorageHandler = this.storageHandler === undefined ? DEFAULT_STORAGE_HANDLER : this.storageHandler;\n        while (Date.now() < MAX_TIME) {\n            await delay(30);\n            let lockObj = STORAGE.getItemSync(STORAGE_KEY);\n            if (lockObj === null) {\n                const TIMEOUT_KEY = `${this.id}-${lockKey}-${iat}`;\n                // there is a problem if setItem happens at the exact same time for 2 different processes.. so we add some random delay here.\n                await delay(Math.floor(Math.random() * 25));\n                STORAGE.setItemSync(STORAGE_KEY, JSON.stringify({\n                    id: this.id,\n                    iat,\n                    timeoutKey: TIMEOUT_KEY,\n                    timeAcquired: Date.now(),\n                    timeRefreshed: Date.now()\n                }));\n                await delay(30);    // this is to prevent race conditions. This time must be more than the time it takes for storage.setItem\n                let lockObjPostDelay = STORAGE.getItemSync(STORAGE_KEY);\n                if (lockObjPostDelay !== null) {\n                    let parsedLockObjPostDelay = JSON.parse(lockObjPostDelay);\n                    if (parsedLockObjPostDelay.id === this.id && parsedLockObjPostDelay.iat === iat) {\n                        this.acquiredIatSet.add(iat);\n                        this.refreshLockWhileAcquired(STORAGE_KEY, iat);\n                        return true;\n                    }\n                }\n            } else {\n                SuperTokensLock.lockCorrector(this.storageHandler === undefined ? DEFAULT_STORAGE_HANDLER : this.storageHandler);\n                await this.waitForSomethingToChange(MAX_TIME);\n\n            }\n            iat = Date.now() + generateRandomString(4);\n        }\n        return false;\n    }\n\n    private async refreshLockWhileAcquired(storageKey: string, iat: string) {\n        setTimeout(async () => {\n            await getProcessLock().lock(iat);\n            if (!this.acquiredIatSet.has(iat)) {\n                getProcessLock().unlock(iat);\n                return;\n            }\n            const STORAGE: StorageHandler = this.storageHandler === undefined ? DEFAULT_STORAGE_HANDLER : this.storageHandler;\n            let lockObj = STORAGE.getItemSync(storageKey);\n            if (lockObj !== null) {\n                let parsedLockObj = JSON.parse(lockObj);\n                parsedLockObj.timeRefreshed = Date.now();\n                STORAGE.setItemSync(storageKey, JSON.stringify(parsedLockObj));\n                getProcessLock().unlock(iat);\n            } else {\n                getProcessLock().unlock(iat);\n                return;\n            }\n            this.refreshLockWhileAcquired(storageKey, iat);\n        }, 1000);\n    }\n\n    private async waitForSomethingToChange(MAX_TIME: number) {\n        await new Promise(resolve => {\n            let resolvedCalled = false;\n            let startedAt = Date.now();\n            const MIN_TIME_TO_WAIT = 50;    // ms\n            let removedListeners = false;\n            function stopWaiting() {\n                if (!removedListeners) {\n                    window.removeEventListener('storage', stopWaiting);\n                    SuperTokensLock.removeFromWaiting(stopWaiting);\n                    clearTimeout(timeOutId);\n                    removedListeners = true;\n                }\n                if (!resolvedCalled) {\n                    resolvedCalled = true;\n                    let timeToWait = MIN_TIME_TO_WAIT - (Date.now() - startedAt);\n                    if (timeToWait > 0) {\n                        setTimeout(resolve, timeToWait);\n                    } else {\n                        resolve(null);\n                    }\n                }\n            }\n            window.addEventListener('storage', stopWaiting);\n            SuperTokensLock.addToWaiting(stopWaiting);\n            let timeOutId = setTimeout(stopWaiting, Math.max(0, MAX_TIME - Date.now()));\n        });\n    }\n\n    private static addToWaiting(func: any) {\n        this.removeFromWaiting(func);\n        if (SuperTokensLock.waiters === undefined) {\n            return;\n        }\n        SuperTokensLock.waiters.push(func);\n    }\n\n    private static removeFromWaiting(func: any) {\n        if (SuperTokensLock.waiters === undefined) {\n            return;\n        }\n        SuperTokensLock.waiters = SuperTokensLock.waiters.filter(i => i !== func);\n    }\n\n    private static notifyWaiters() {\n        if (SuperTokensLock.waiters === undefined) {\n            return;\n        }\n        let waiters = [...SuperTokensLock.waiters];    // so that if Lock.waiters is changed it's ok.\n        waiters.forEach(i => i());\n    }\n\n    /**\n     * @function releaseLock\n     * @memberOf Lock\n     * @param {string} lockKey - Key for which lock is being released\n     * @returns {void}\n     * @description Release a lock.\n     */\n    async releaseLock(lockKey: string) {\n        return await this.releaseLock__private__(lockKey);\n    }\n\n    /**\n     * @function releaseLock\n     * @memberOf Lock\n     * @param {string} lockKey - Key for which lock is being released\n     * @returns {void}\n     * @description Release a lock.\n     */\n    private async releaseLock__private__(lockKey: string) {\n        const STORAGE: StorageHandler = this.storageHandler === undefined ? DEFAULT_STORAGE_HANDLER : this.storageHandler;\n        const STORAGE_KEY = `${LOCK_STORAGE_KEY}-${lockKey}`;\n        let lockObj = STORAGE.getItemSync(STORAGE_KEY);\n        if (lockObj === null) {\n            return;\n        }\n        let parsedlockObj = JSON.parse(lockObj);\n        if (parsedlockObj.id === this.id) {\n            await getProcessLock().lock(parsedlockObj.iat);\n\n            this.acquiredIatSet.delete(parsedlockObj.iat);\n            STORAGE.removeItemSync(STORAGE_KEY);\n\n            getProcessLock().unlock(parsedlockObj.iat);\n\n            SuperTokensLock.notifyWaiters();\n        }\n    }\n\n    /**\n     * @function lockCorrector\n     * @returns {void}\n     * @description If a lock is acquired by a tab and the tab is closed before the lock is\n     *              released, this function will release those locks\n     */\n    private static lockCorrector(storageHandler: StorageHandler) {\n        const MIN_ALLOWED_TIME = Date.now() - 5000;\n        const STORAGE = storageHandler;\n        const KEYS: string[] = [];\n        let currIndex = 0;\n        while (true) {\n            let key = STORAGE.keySync(currIndex);\n            if (key === null) {\n                break;\n            }\n            KEYS.push(key);\n            currIndex++;\n        }\n        let notifyWaiters = false;\n        for (let i = 0; i < KEYS.length; i++) {\n            const LOCK_KEY = KEYS[i];\n            if (LOCK_KEY.includes(LOCK_STORAGE_KEY)) {\n                let lockObj = STORAGE.getItemSync(LOCK_KEY);\n                if (lockObj !== null) {\n                    let parsedlockObj = JSON.parse(lockObj);\n                    if ((parsedlockObj.timeRefreshed === undefined && parsedlockObj.timeAcquired < MIN_ALLOWED_TIME) ||\n                        (parsedlockObj.timeRefreshed !== undefined && parsedlockObj.timeRefreshed < MIN_ALLOWED_TIME)) {\n                        STORAGE.removeItemSync(LOCK_KEY);\n                        notifyWaiters = true;\n                    }\n                }\n            }\n        }\n        if (notifyWaiters) {\n            SuperTokensLock.notifyWaiters();\n        }\n    }\n}\n","import Lock from \"../vendor/browser-tabs-lock\";\n\nconst DEFAULT_LOCK_TIMEOUT_MS = 10_000;\n\nexport function withLock<T>(\n  lockName: string,\n  callback: () => T | Promise<T>,\n  { timeout = DEFAULT_LOCK_TIMEOUT_MS } = {},\n): Promise<T> {\n  if (!lockName) {\n    throw new TypeError(\"lockName is required and must be a non-empty string.\");\n  }\n\n  return \"locks\" in navigator\n    ? withNativeLock(lockName, callback, timeout)\n    : withVendorLock(lockName, callback, timeout);\n}\n\nasync function withNativeLock<T>(\n  lockName: string,\n  callback: () => T | Promise<T>,\n  timeout: number,\n) {\n  try {\n    return await navigator.locks.request(\n      lockName,\n      { signal: AbortSignal.timeout(timeout) },\n      callback,\n    );\n  } catch (error) {\n    if (error instanceof DOMException) {\n      switch (error.name) {\n        case \"AbortError\":\n          throw new LockError(\"AcquisitionTimeoutError\", lockName, \"Native\");\n\n        case \"InvalidStateError\":\n        case \"NotSupportedError\":\n        case \"SecurityError\":\n        // These are documented but we currently don't handle them\n        // in any particular way and let them bubble up.\n      }\n    }\n\n    throw error;\n  }\n}\n\nasync function withVendorLock<T>(\n  lockName: string,\n  callback: () => T | Promise<T>,\n  timeout: number,\n) {\n  const lock = new Lock();\n\n  try {\n    if (await lock.acquireLock(lockName, timeout)) {\n      return await callback();\n    } else {\n      throw new LockError(\"AcquisitionTimeoutError\", lockName, \"Vendor\");\n    }\n  } finally {\n    await lock.releaseLock(lockName);\n  }\n}\n\nexport class LockError extends Error {\n  constructor(\n    override readonly name: \"AcquisitionTimeoutError\",\n    readonly lockName: string,\n    type: \"Native\" | \"Vendor\",\n  ) {\n    super(`Lock acquisition timed out for \"${lockName}\" (${type})`);\n  }\n}\n","import { User, UserRaw } from \"../interfaces\";\n\nexport const deserializeUser = (user: UserRaw): User => ({\n  object: user.object,\n  id: user.id,\n  email: user.email,\n  emailVerified: user.email_verified,\n  firstName: user.first_name,\n  profilePictureUrl: user.profile_picture_url,\n  lastName: user.last_name,\n  lastSignInAt: user.last_sign_in_at,\n  externalId: user.external_id,\n  createdAt: user.created_at,\n  updatedAt: user.updated_at,\n});\n","import {\n  AuthenticationResponse,\n  AuthenticationResponseRaw,\n} from \"../interfaces\";\nimport { deserializeUser } from \"./user.serializer\";\n\nexport const deserializeAuthenticationResponse = (\n  authenticationResponse: AuthenticationResponseRaw,\n): AuthenticationResponse => {\n  const {\n    user,\n    organization_id,\n    access_token,\n    refresh_token,\n    impersonator,\n    ...rest\n  } = authenticationResponse;\n\n  return {\n    user: deserializeUser(user),\n    organizationId: organization_id,\n    accessToken: access_token,\n    refreshToken: refresh_token,\n    impersonator,\n    ...rest,\n  };\n};\n","import { CodeExchangeError, RefreshError } from \"./errors\";\nimport {\n  AuthenticationResponseRaw,\n  GetAuthorizationUrlOptions,\n} from \"./interfaces\";\nimport { deserializeAuthenticationResponse } from \"./serializers\";\nimport { toQueryString } from \"./utils\";\n\nconst DEFAULT_HOSTNAME = \"api.workos.com\";\n\nexport class HttpClient {\n  readonly #baseUrl: string;\n  readonly #clientId: string;\n\n  constructor({\n    clientId,\n    hostname = DEFAULT_HOSTNAME,\n    port,\n    https = true,\n  }: {\n    clientId: string;\n    hostname?: string;\n    port?: number;\n    https?: boolean;\n  }) {\n    this.#baseUrl = `${https ? \"https\" : \"http\"}://${hostname}${\n      port ? `:${port}` : \"\"\n    }`;\n    this.#clientId = clientId;\n  }\n\n  async authenticateWithRefreshToken({\n    refreshToken,\n    organizationId,\n    useCookie,\n  }: {\n    refreshToken: string | undefined;\n    organizationId?: string;\n    useCookie: boolean;\n  }) {\n    const response = await this.#post(\"/user_management/authenticate\", {\n      useCookie,\n      body: {\n        client_id: this.#clientId,\n        grant_type: \"refresh_token\",\n        ...(!useCookie && { refresh_token: refreshToken }),\n        organization_id: organizationId,\n      },\n    });\n\n    if (response.ok) {\n      const data = (await response.json()) as AuthenticationResponseRaw;\n      return deserializeAuthenticationResponse(data);\n    } else {\n      const error = (await response.json()) as any;\n      throw new RefreshError(error.error_description);\n    }\n  }\n\n  async authenticateWithCode({\n    code,\n    codeVerifier,\n    useCookie,\n  }: {\n    code: string;\n    codeVerifier: string;\n    useCookie: boolean;\n  }) {\n    const response = await this.#post(\"/user_management/authenticate\", {\n      useCookie,\n      body: {\n        code,\n        client_id: this.#clientId,\n        grant_type: \"authorization_code\",\n        code_verifier: codeVerifier,\n      },\n    });\n\n    if (response.ok) {\n      const data = (await response.json()) as AuthenticationResponseRaw;\n      return deserializeAuthenticationResponse(data);\n    }\n\n    const error = await response.json();\n    throw new CodeExchangeError(error.error_description);\n  }\n\n  #post(\n    path: \"/user_management/authenticate\",\n    { body, useCookie }: { body: Record<string, unknown>; useCookie: boolean },\n  ) {\n    return fetch(new URL(path, this.#baseUrl), {\n      method: \"POST\",\n      ...(useCookie && { credentials: \"include\" }),\n      headers: {\n        Accept: \"application/json, text/plain, */*\",\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(body),\n    });\n  }\n\n  getAuthorizationUrl({\n    connectionId,\n    context,\n    domainHint,\n    loginHint,\n    organizationId,\n    provider = \"authkit\",\n    redirectUri,\n    state,\n    screenHint,\n    passwordResetToken,\n    invitationToken,\n    codeChallenge,\n    codeChallengeMethod,\n  }: GetAuthorizationUrlOptions) {\n    if (!provider && !connectionId && !organizationId) {\n      throw new TypeError(\n        `Incomplete arguments. Need to specify either a 'connectionId', 'organizationId', or 'provider'.`,\n      );\n    }\n\n    if (provider !== \"authkit\" && screenHint) {\n      throw new TypeError(\n        `'screenHint' is only supported for 'authkit' provider`,\n      );\n    }\n\n    if (context) {\n      console.warn(\n        `\\`context\\` is deprecated. We previously required initiate login endpoints to return the\n\\`context\\` query parameter when getting the authorization URL. This is no longer necessary.`,\n      );\n    }\n\n    const query = toQueryString({\n      connection_id: connectionId,\n      organization_id: organizationId,\n      domain_hint: domainHint,\n      login_hint: loginHint,\n      provider,\n      client_id: this.#clientId,\n      redirect_uri: redirectUri,\n      response_type: \"code\",\n      state,\n      screen_hint: screenHint,\n      invitation_token: invitationToken,\n      password_reset_token: passwordResetToken,\n      code_challenge: codeChallenge,\n      code_challenge_method: codeChallengeMethod,\n    });\n\n    return `${this.#baseUrl}/user_management/authorize?${query}`;\n  }\n\n  getLogoutUrl({\n    sessionId,\n    returnTo,\n  }: {\n    sessionId: string;\n    returnTo: string | undefined;\n  }) {\n    const url = new URL(\"/user_management/sessions/logout\", this.#baseUrl);\n\n    url.searchParams.set(\"session_id\", sessionId);\n    if (returnTo) {\n      url.searchParams.set(\"return_to\", returnTo);\n    }\n\n    return url;\n  }\n}\n","import {\n  AuthenticationResponse,\n  CreateClientOptions,\n  OnRefreshResponse,\n  User,\n} from \"./interfaces\";\nimport { NoClientIdProvidedException } from \"./exceptions\";\nimport {\n  isRedirectCallback,\n  memoryStorage,\n  createPkceChallenge,\n  setSessionData,\n  removeSessionData,\n  storageKeys,\n} from \"./utils\";\nimport { getRefreshToken, getClaims } from \"./utils/session-data\";\nimport { RedirectParams } from \"./interfaces/create-client-options.interface\";\nimport { LoginRequiredError, RefreshError } from \"./errors\";\nimport { withLock, LockError } from \"./utils/locking\";\nimport { HttpClient } from \"./http-client\";\n\ninterface RedirectOptions {\n  /**\n   *  @deprecated We previously required initiate login endpoints to return the `context`\n   *  query parameter when getting the authorization URL. This is no longer necessary.\n   */\n  context?: string;\n  invitationToken?: string;\n  loginHint?: string;\n  organizationId?: string;\n  passwordResetToken?: string;\n  state?: any;\n  type: \"sign-in\" | \"sign-up\";\n}\n\ntype State =\n  | { tag: \"INITIAL\" }\n  | { tag: \"AUTHENTICATING\"; response: Promise<AuthenticationResponse> }\n  | { tag: \"AUTHENTICATED\" }\n  | { tag: \"ERROR\" };\n\nexport const ORGANIZATION_ID_SESSION_STORAGE_KEY = \"workos_organization_id\";\n\nconst REFRESH_LOCK_NAME = \"WORKOS_REFRESH_SESSION\";\n\nexport class Client {\n  #state: State;\n  #refreshTimer: ReturnType<typeof setTimeout> | undefined;\n\n  readonly #httpClient: HttpClient;\n  readonly #redirectUri: string;\n  readonly #devMode: boolean;\n  readonly #onBeforeAutoRefresh: () => boolean;\n  readonly #onRedirectCallback: (params: RedirectParams) => void;\n  readonly #onRefreshCallback:\n    | ((response: OnRefreshResponse) => void)\n    | undefined;\n  readonly #onRefreshFailure:\n    | ((params: { signIn: () => Promise<void> }) => void)\n    | undefined;\n  readonly #refreshBufferInterval: number;\n\n  constructor(\n    clientId: string,\n    {\n      apiHostname: hostname,\n      https,\n      port,\n      redirectUri = window.origin,\n      devMode = location.hostname === \"localhost\" ||\n        location.hostname === \"127.0.0.1\",\n      // refresh if this is true\n      onBeforeAutoRefresh = () => {\n        return !document.hidden;\n      },\n      onRedirectCallback = (_: RedirectParams) => {},\n      onRefresh,\n      onRefreshFailure,\n      refreshBufferInterval = 10,\n    }: CreateClientOptions = {},\n  ) {\n    if (!clientId) {\n      throw new NoClientIdProvidedException();\n    }\n\n    this.#httpClient = new HttpClient({ clientId, hostname, port, https });\n    this.#devMode = devMode;\n    this.#redirectUri = redirectUri;\n    this.#state = { tag: \"INITIAL\" };\n    this.#onBeforeAutoRefresh = onBeforeAutoRefresh;\n    this.#onRedirectCallback = onRedirectCallback;\n    this.#onRefreshCallback = onRefresh;\n    this.#onRefreshFailure = onRefreshFailure;\n    this.#refreshBufferInterval = refreshBufferInterval;\n  }\n\n  async initialize() {\n    if (this.#state.tag !== \"INITIAL\") {\n      return;\n    }\n\n    const searchParams = new URLSearchParams(window.location.search);\n    if (isRedirectCallback(this.#redirectUri, searchParams)) {\n      await this.#handleCallback();\n    } else if (\n      document.cookie.includes(\"workos-has-session=\") ||\n      getRefreshToken({ devMode: this.#devMode })\n    ) {\n      try {\n        await this.#refreshSession();\n        this.#scheduleAutomaticRefresh();\n      } catch {\n        // this is expected to fail if a user doesn't\n        // have a session. do nothing.\n      }\n    }\n  }\n\n  async getSignInUrl(opts: Omit<RedirectOptions, \"type\"> = {}) {\n    const url = await this.#getAuthorizationUrl({ ...opts, type: \"sign-in\" });\n    return url;\n  }\n\n  async getSignUpUrl(opts: Omit<RedirectOptions, \"type\"> = {}) {\n    const url = await this.#getAuthorizationUrl({ ...opts, type: \"sign-up\" });\n    return url;\n  }\n\n  async signIn(opts: Omit<RedirectOptions, \"type\"> = {}) {\n    const url = await this.#getAuthorizationUrl({ ...opts, type: \"sign-in\" });\n    window.location.assign(url);\n  }\n\n  async signUp(opts: Omit<RedirectOptions, \"type\"> = {}) {\n    const url = await this.#getAuthorizationUrl({ ...opts, type: \"sign-up\" });\n    window.location.assign(url);\n  }\n\n  signOut(options?: { returnTo?: string; navigate?: true }): void;\n  signOut(options?: { returnTo?: string; navigate: false }): Promise<void>;\n  signOut(\n    options: { returnTo?: string; navigate?: boolean } = { navigate: true },\n  ): void | Promise<void> {\n    const navigate = options.navigate ?? true;\n    const accessToken = memoryStorage.getItem(storageKeys.accessToken);\n    if (typeof accessToken !== \"string\") return;\n    const { sid: sessionId } = getClaims(accessToken);\n\n    const url = this.#httpClient.getLogoutUrl({\n      sessionId,\n      returnTo: options?.returnTo,\n    });\n\n    if (url) {\n      removeSessionData({ devMode: this.#devMode });\n\n      if (navigate) {\n        window.location.assign(url);\n      } else {\n        return new Promise(async (resolve) => {\n          fetch(url, {\n            mode: \"no-cors\",\n            credentials: \"include\",\n          })\n            .catch((error) => {\n              console.warn(\"AuthKit: Failed to send logout request\", error);\n            })\n            .finally(resolve);\n        });\n      }\n    }\n  }\n\n  async getAccessToken(options?: { forceRefresh?: boolean }): Promise<string> {\n    if (options?.forceRefresh || this.#shouldRefresh()) {\n      try {\n        await this.#refreshSession();\n      } catch (err) {\n        if (err instanceof RefreshError) {\n          throw new LoginRequiredError();\n        } else {\n          throw err;\n        }\n      }\n    }\n\n    const accessToken = this.#getAccessToken();\n    if (!accessToken) {\n      throw new LoginRequiredError();\n    }\n\n    return accessToken;\n  }\n\n  getUser() {\n    const user = memoryStorage.getItem(storageKeys.user);\n    return user ? (user as User) : null;\n  }\n\n  dispose() {\n    clearTimeout(this.#refreshTimer);\n    memoryStorage.reset();\n  }\n\n  async #handleCallback() {\n    if (this.#state.tag !== \"INITIAL\") {\n      return;\n    }\n\n    const url = new URL(window.location.href);\n    const code = url.searchParams.get(\"code\");\n    const stateParam = url.searchParams.get(\"state\");\n    const state = stateParam ? JSON.parse(stateParam) : undefined;\n\n    // grab the previously stored code verifier from session storage\n    const codeVerifier = window.sessionStorage.getItem(\n      storageKeys.codeVerifier,\n    );\n\n    if (code) {\n      if (codeVerifier) {\n        try {\n          this.#state = {\n            tag: \"AUTHENTICATING\",\n            response: this.#httpClient.authenticateWithCode({\n              code,\n              codeVerifier,\n              useCookie: this.#useCookie,\n            }),\n          };\n          const authenticationResponse = await this.#state.response;\n\n          if (authenticationResponse) {\n            this.#state = { tag: \"AUTHENTICATED\" };\n            this.#scheduleAutomaticRefresh();\n            setSessionData(authenticationResponse, { devMode: this.#devMode });\n            this.#onRefresh(authenticationResponse);\n            this.#onRedirectCallback({ state, ...authenticationResponse });\n          }\n        } catch (error) {\n          this.#state = { tag: \"ERROR\" };\n          console.error(error);\n        }\n      } else {\n        this.#state = { tag: \"ERROR\" };\n        console.error(`Couldn't exchange code.\n\nAn authorization_code was supplied for a login which did not originate at the application. This could happen for various reasons:\n\n* This could have been an attempted Login CSRF attack. You were not affected.\n* The developer may not have configured a Login Initiation endpoint.`);\n      }\n    }\n\n    // Remove code from search params\n    const cleanUrl = new URL(window.location.toString());\n    cleanUrl.search = \"\";\n    window.sessionStorage.removeItem(storageKeys.codeVerifier);\n    window.history.replaceState({}, \"\", cleanUrl);\n  }\n\n  async #scheduleAutomaticRefresh() {\n    this.#refreshTimer = setTimeout(() => {\n      if (this.#shouldRefresh() && this.#onBeforeAutoRefresh()) {\n        this.#refreshSession()\n          .catch((e) => {\n            console.debug(e);\n          })\n          .finally(() => this.#scheduleAutomaticRefresh());\n      } else {\n        this.#scheduleAutomaticRefresh();\n      }\n    }, 1000);\n  }\n\n  /**\n   * Switches to the requested organization.\n   *\n   * Redirects to the hosted login page for the given organization if the\n   * switch is unsuccessful.\n   */\n  async switchToOrganization({\n    organizationId,\n    signInOpts = {},\n  }: {\n    organizationId: string;\n    signInOpts?: Omit<RedirectOptions, \"type\" | \"organizationId\">;\n  }) {\n    try {\n      await this.#refreshSession({ organizationId });\n    } catch (error) {\n      if (error instanceof RefreshError) {\n        this.signIn({ ...signInOpts, organizationId });\n      } else {\n        throw error;\n      }\n    }\n  }\n\n  async #refreshSession({ organizationId }: { organizationId?: string } = {}) {\n    if (this.#state.tag === \"AUTHENTICATING\") {\n      await this.#state.response;\n      return;\n    }\n\n    const beginningState = this.#state;\n\n    this.#state = {\n      tag: \"AUTHENTICATING\",\n      response: this.#doRefresh({ organizationId, beginningState }),\n    };\n\n    await this.#state.response;\n  }\n\n  async #doRefresh({\n    organizationId,\n    beginningState,\n  }: {\n    organizationId?: string;\n    beginningState: State;\n  }): Promise<AuthenticationResponse> {\n    try {\n      return await withLock(REFRESH_LOCK_NAME, async () => {\n        if (organizationId) {\n          sessionStorage.setItem(\n            ORGANIZATION_ID_SESSION_STORAGE_KEY,\n            organizationId,\n          );\n        } else {\n          const accessToken = this.#getAccessToken();\n          if (accessToken) {\n            organizationId = getClaims(accessToken)?.org_id;\n          } else {\n            organizationId =\n              sessionStorage.getItem(ORGANIZATION_ID_SESSION_STORAGE_KEY) ??\n              undefined;\n          }\n        }\n\n        const authenticationResponse =\n          await this.#httpClient.authenticateWithRefreshToken({\n            refreshToken: getRefreshToken({ devMode: this.#devMode }),\n            organizationId,\n            useCookie: this.#useCookie,\n          });\n\n        this.#state = { tag: \"AUTHENTICATED\" };\n        setSessionData(authenticationResponse, { devMode: this.#devMode });\n        this.#onRefresh(authenticationResponse);\n        return authenticationResponse;\n      });\n    } catch (error) {\n      if (\n        error instanceof LockError &&\n        error.name === \"AcquisitionTimeoutError\"\n      ) {\n        console.warn(\"Couldn't acquire refresh lock.\");\n\n        // preserving the original state so that we can try again next time\n        this.#state = beginningState;\n        throw error;\n      }\n\n      if (beginningState.tag !== \"INITIAL\") {\n        console.debug(error);\n      }\n\n      if (error instanceof RefreshError) {\n        removeSessionData({ devMode: this.#devMode });\n        // fire the refresh failure UNLESS this is the initial refresh attempt\n        // (the initial refresh is expected to fail if a user has not logged in\n        // ever or recently)\n        beginningState.tag !== \"INITIAL\" &&\n          this.#onRefreshFailure &&\n          this.#onRefreshFailure({ signIn: this.signIn.bind(this) });\n\n        this.#state = { tag: \"ERROR\" };\n      } else {\n        // transitioning into the AUTHENTICATED state ensures that we will\n        // attempt to refresh the token on future getAccessToken calls()\n        //\n        // this could maybe be a new state for clarity? TEMPORARY_ERROR?\n        this.#state = { tag: \"AUTHENTICATED\" };\n      }\n\n      throw error;\n    }\n  }\n\n  #shouldRefresh() {\n    switch (this.#state.tag) {\n      case \"INITIAL\":\n      case \"AUTHENTICATING\":\n        return true;\n      case \"ERROR\":\n        return false;\n      case \"AUTHENTICATED\":\n        const accessToken = memoryStorage.getItem(storageKeys.accessToken) as\n          | string\n          | undefined;\n        const expiresAt = memoryStorage.getItem(storageKeys.expiresAt) as\n          | number\n          | undefined;\n\n        if (!accessToken || !expiresAt) {\n          return true;\n        }\n\n        const tokenRefreshBufferInSeconds = this.#refreshBufferInterval * 1000;\n        const refreshTime = expiresAt - tokenRefreshBufferInSeconds;\n        return refreshTime < Date.now();\n    }\n  }\n\n  async #getAuthorizationUrl({\n    context,\n    invitationToken,\n    loginHint,\n    organizationId,\n    passwordResetToken,\n    state,\n    type,\n  }: RedirectOptions) {\n    const { codeVerifier, codeChallenge } = await createPkceChallenge();\n    // store the code verifier in session storage for later use (after the redirect back from authkit)\n    window.sessionStorage.setItem(storageKeys.codeVerifier, codeVerifier);\n    const url = this.#httpClient.getAuthorizationUrl({\n      codeChallenge,\n      codeChallengeMethod: \"S256\",\n      context,\n      invitationToken,\n      loginHint,\n      organizationId,\n      passwordResetToken,\n      redirectUri: this.#redirectUri,\n      screenHint: type,\n      state: state ? JSON.stringify(state) : undefined,\n    });\n\n    return url;\n  }\n\n  #getAccessToken() {\n    return memoryStorage.getItem(storageKeys.accessToken) as string | undefined;\n  }\n\n  get #useCookie() {\n    return !this.#devMode;\n  }\n\n  async #onRefresh(authenticationResponse: AuthenticationResponse) {\n    if (this.#onRefreshCallback) {\n      // there's no good reason for client code to access the refresh token\n      const { refreshToken: _refreshToken, ...onRefreshData } =\n        authenticationResponse;\n      this.#onRefreshCallback(onRefreshData);\n    }\n  }\n}\n\nexport async function createClient(\n  clientId: string,\n  options: CreateClientOptions = {},\n) {\n  const client = new Client(clientId, options);\n\n  await client.initialize();\n\n  return client;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}