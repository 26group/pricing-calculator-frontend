interface User {
    object: "user";
    id: string;
    email: string;
    emailVerified: boolean;
    profilePictureUrl: string | null;
    firstName: string | null;
    lastName: string | null;
    lastSignInAt: string | null;
    externalId: string | undefined;
    createdAt: string;
    updatedAt: string;
}

interface Impersonator {
    email: string;
    reason: string | null;
}

interface AuthenticationResponse {
    user: User;
    accessToken: string;
    refreshToken: string;
    organizationId?: string;
    impersonator?: Impersonator;
}
type OnRefreshResponse = Omit<AuthenticationResponse, "refreshToken">;

interface CreateClientOptions {
    /**
     * How many seconds before the access token expiration to attempt a refresh.
     */
    refreshBufferInterval?: number;
    apiHostname?: string;
    https?: boolean;
    port?: number;
    redirectUri?: string;
    devMode?: boolean;
    onRedirectCallback?: (_: RedirectParams) => void;
    onBeforeAutoRefresh?: () => boolean;
    onRefresh?: (_: OnRefreshResponse) => void;
    onRefreshFailure?: (args: {
        signIn: Awaited<ReturnType<typeof createClient>>["signIn"];
    }) => void;
}
interface RedirectParams extends AuthenticationResponse {
    state: Record<string, any> | null;
}

/**
 * JWT Payload Interface
 */
interface JWTPayload {
    /**
     * Session ID of the JWT, used to identify the session
     */
    sid: string;
    /**
     * Issuer of the JWT
     */
    iss: string;
    /**
     * Subject of the JWT
     */
    sub: string;
    /**
     * Audience of the JWT, can be a single string or an array of strings
     */
    aud?: string | string[];
    /**
     * Expiration time of the JWT, represented as a Unix timestamp
     */
    exp: number;
    /**
     * Issued at time of the JWT, represented as a Unix timestamp
     */
    iat: number;
    /**
     * JWT ID, a unique identifier for the JWT
     */
    jti: string;
    /**
     * Organization ID associated with the JWT
     */
    org_id?: string;
    /**
     * Role of the user associated with the JWT
     */
    role?: string;
    /**
     * Roles of the user associated with the JWT
     */
    roles?: string[];
    /**
     * Permissions granted to the user associated with the JWT
     */
    permissions?: string[];
    /**
     * Feature flags granted to the organization associated with the JWT
     */
    feature_flags?: string[];
}

interface RedirectOptions {
    /**
     *  @deprecated We previously required initiate login endpoints to return the `context`
     *  query parameter when getting the authorization URL. This is no longer necessary.
     */
    context?: string;
    invitationToken?: string;
    loginHint?: string;
    organizationId?: string;
    passwordResetToken?: string;
    state?: any;
    type: "sign-in" | "sign-up";
}
declare class Client {
    #private;
    constructor(clientId: string, { apiHostname: hostname, https, port, redirectUri, devMode, onBeforeAutoRefresh, onRedirectCallback, onRefresh, onRefreshFailure, refreshBufferInterval, }?: CreateClientOptions);
    initialize(): Promise<void>;
    getSignInUrl(opts?: Omit<RedirectOptions, "type">): Promise<string>;
    getSignUpUrl(opts?: Omit<RedirectOptions, "type">): Promise<string>;
    signIn(opts?: Omit<RedirectOptions, "type">): Promise<void>;
    signUp(opts?: Omit<RedirectOptions, "type">): Promise<void>;
    signOut(options?: {
        returnTo?: string;
        navigate?: true;
    }): void;
    signOut(options?: {
        returnTo?: string;
        navigate: false;
    }): Promise<void>;
    getAccessToken(options?: {
        forceRefresh?: boolean;
    }): Promise<string>;
    getUser(): User | null;
    dispose(): void;
    /**
     * Switches to the requested organization.
     *
     * Redirects to the hosted login page for the given organization if the
     * switch is unsuccessful.
     */
    switchToOrganization({ organizationId, signInOpts, }: {
        organizationId: string;
        signInOpts?: Omit<RedirectOptions, "type" | "organizationId">;
    }): Promise<void>;
}
declare function createClient(clientId: string, options?: CreateClientOptions): Promise<Client>;

/**
 * Retrieves the claims from a JWT access token.
 * @param accessToken - The JWT access token to decode.
 * @returns The decoded JWT payload, which includes the claims.
 */
declare function getClaims<T = {}>(accessToken: string): JWTPayload & T;

declare class AuthKitError extends Error {
}
declare class LoginRequiredError extends AuthKitError {
    readonly message: string;
}

export { AuthKitError, type AuthenticationResponse, type JWTPayload, LoginRequiredError, type OnRefreshResponse, type User, createClient, getClaims };
