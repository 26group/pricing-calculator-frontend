{"version":3,"sources":["../src/exceptions/no-client-id-provided.exception.ts","../src/utils/is-redirect-callback.ts","../src/utils/memory-storage.ts","../src/utils/pkce.ts","../src/utils/jwt.ts","../src/utils/storage-keys.ts","../src/utils/session-data.ts","../src/utils/to-query-string.ts","../src/errors.ts","../src/vendor/browser-tabs-lock/processLock.ts","../src/vendor/browser-tabs-lock/index.ts","../src/utils/locking.ts","../src/serializers/user.serializer.ts","../src/serializers/authentication-response.serializer.ts","../src/http-client.ts","../src/create-client.ts"],"sourcesContent":["export class NoClientIdProvidedException extends Error {\n  readonly status: number = 500;\n  readonly name: string = \"NoClientIdProvidedException\";\n  readonly message: string = `Missing Client ID. Pass it to the constructor (createClient(\"client_01HXRMBQ9BJ3E7QSTQ9X2PHVB7\"))`;\n}\n","export function isRedirectCallback(\n  redirectUri: string,\n  searchParams: URLSearchParams,\n) {\n  const hasCode = searchParams.has(\"code\");\n  if (!hasCode) return false;\n\n  const { pathname: currentPathName } = window.location;\n  const redirectPathname = new URL(redirectUri).pathname;\n  return (\n    currentPathName === redirectPathname ||\n    currentPathName === `${redirectPathname}/`\n  );\n}\n","function createMemoryStorage() {\n  let _store: { [key: string]: unknown } = {};\n\n  function setItem(key: string, value: unknown): void {\n    _store[key] = value;\n  }\n\n  function getItem(key: string): unknown {\n    return _store[key];\n  }\n\n  function removeItem(key: string): void {\n    delete _store[key];\n  }\n\n  function reset(): void {\n    _store = {};\n  }\n\n  return {\n    setItem,\n    getItem,\n    removeItem,\n    reset,\n  };\n}\n\nconst memoryStorage = createMemoryStorage();\n\nexport { memoryStorage };\n","export async function createPkceChallenge() {\n  const codeVerifier = createCodeVerifier();\n  const codeChallenge = await createCodeChallenge(codeVerifier);\n\n  return { codeVerifier, codeChallenge };\n}\n\nfunction createCodeVerifier() {\n  const randomBytes = crypto.getRandomValues(new Uint32Array(96));\n  return base64urlEncode(randomBytes);\n}\n\nasync function createCodeChallenge(codeVerifier: string) {\n  const hashed = await sha256(codeVerifier);\n  return base64urlEncode(hashed);\n}\n\nfunction base64urlEncode(buffer: ArrayBuffer): string {\n  return btoa(\n    Array.from(new Uint8Array(buffer), (b) => String.fromCharCode(b)).join(\"\"),\n  )\n    .replace(/\\+/g, \"-\")\n    .replace(/\\//g, \"_\")\n    .replace(/=+$/, \"\");\n}\n\nfunction sha256(plain: string): Promise<ArrayBuffer> {\n  const encoder = new TextEncoder();\n  const data = encoder.encode(plain);\n  return crypto.subtle.digest(\"SHA-256\", data);\n}\n","import { JWTHeader, JWTPayload } from \"../interfaces/jwt.interface\";\n\n/**\n * Decodes a base64url encoded string\n * @param input The base64url string to decode\n * @returns The decoded string\n */\nfunction decodeBase64Url(input: string): string {\n  const base64 = input.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  const padding = \"=\".repeat((4 - (base64.length % 4)) % 4);\n  return atob(base64 + padding);\n}\n\n/**\n * Decodes a JWT token and returns its header and payload\n * @param token The JWT token to decode\n * @return An object containing the decoded header and payload\n * @throws Error if the token is not in a valid JWT format or if decoding fails\n */\n// should replace this with jose if we ever need to verify the JWT\nexport function decodeJwt<T = {}>(\n  token: string,\n): {\n  header: JWTHeader;\n  payload: JWTPayload & T;\n} {\n  const parts = token.split(\".\");\n\n  if (parts.length !== 3) {\n    throw new Error(\"Invalid JWT format\");\n  }\n\n  try {\n    const header = JSON.parse(decodeBase64Url(parts[0])) as JWTHeader;\n    const payload = JSON.parse(decodeBase64Url(parts[1])) as JWTPayload & T;\n\n    return { header, payload };\n  } catch (error) {\n    throw new Error(\n      `Failed to decode JWT: ${error instanceof Error ? error.message : String(error)}`,\n    );\n  }\n}\n","export const storageKeys = {\n  codeVerifier: \"workos:code-verifier\",\n  user: \"workos:user\",\n  accessToken: \"workos:access-token\",\n  refreshToken: \"workos:refresh-token\",\n  expiresAt: \"workos:expires-at\",\n} as const;\n","import { AuthenticationResponse, JWTPayload } from \"../interfaces\";\nimport { decodeJwt } from \"./jwt\";\nimport { memoryStorage } from \"./memory-storage\";\nimport { storageKeys } from \"./storage-keys\";\n\n/**\n * Retrieves the claims from a JWT access token.\n * @param accessToken - The JWT access token to decode.\n * @returns The decoded JWT payload, which includes the claims.\n */\nexport function getClaims<T = {}>(accessToken: string): JWTPayload & T {\n  return decodeJwt<T>(accessToken).payload;\n}\n\nexport function setSessionData(\n  data: AuthenticationResponse,\n  { devMode = false } = {},\n) {\n  const { user, accessToken, refreshToken } = data;\n  memoryStorage.setItem(storageKeys.user, user);\n  memoryStorage.setItem(storageKeys.accessToken, accessToken);\n  (devMode ? window.localStorage : memoryStorage).setItem(\n    storageKeys.refreshToken,\n    refreshToken,\n  );\n\n  // compute a local time version of expires at (should avoid issues with slightly-wrong clocks)\n  const { exp, iat } = getClaims(accessToken);\n  const expiresIn = exp - iat;\n  const expiresAt = Date.now() + expiresIn * 1000;\n  memoryStorage.setItem(storageKeys.expiresAt, expiresAt);\n}\n\nexport function removeSessionData({ devMode = false } = {}) {\n  memoryStorage.removeItem(storageKeys.user);\n  memoryStorage.removeItem(storageKeys.accessToken);\n  (devMode ? window.localStorage : memoryStorage).removeItem(\n    storageKeys.refreshToken,\n  );\n}\n\nexport function getRefreshToken({ devMode = false } = {}) {\n  return (devMode ? window.localStorage : memoryStorage).getItem(\n    storageKeys.refreshToken,\n  ) as string | undefined;\n}\n","export function toQueryString(\n  options: Record<string, string | undefined>,\n): string {\n  const searchParams = new URLSearchParams();\n  const keys = Object.keys(options).sort();\n\n  for (const key of keys) {\n    const value = options[key];\n\n    if (value) {\n      searchParams.append(key, value);\n    }\n  }\n\n  return searchParams.toString();\n}\n","export class AuthKitError extends Error {}\nexport class RefreshError extends AuthKitError {}\nexport class CodeExchangeError extends AuthKitError {}\nexport class LoginRequiredError extends AuthKitError {\n  readonly message: string = \"No access token available\";\n}\n","declare let setTimeout: any;\nclass ProcessLocking {\n    static instance: undefined | ProcessLocking;\n    private locked: Map<string, (() => void)[]> = new Map<string, (() => void)[]>();\n\n\n    static getInstance() {\n        if (ProcessLocking.instance === undefined) {\n            ProcessLocking.instance = new ProcessLocking();\n        }\n        return ProcessLocking.instance;\n    }\n\n    private addToLocked = (key: string, toAdd?: () => void) => {\n        let callbacks = this.locked.get(key);\n        if (callbacks === undefined) {\n            if (toAdd === undefined) {\n                this.locked.set(key, []);\n            } else {\n                this.locked.set(key, [toAdd]);\n            }\n        } else {\n            if (toAdd !== undefined) {\n                callbacks.unshift(toAdd);\n                this.locked.set(key, callbacks);\n            }\n        }\n    }\n\n    isLocked = (key: string): boolean => {\n        return this.locked.has(key);\n    }\n\n    lock = (key: string): Promise<void> => {\n        return new Promise<void>((resolve, reject) => {\n            if (this.isLocked(key)) {\n                this.addToLocked(key, resolve);\n            } else {\n                this.addToLocked(key);\n                resolve();\n            }\n        });\n    }\n\n    unlock = (key: string) => {\n        let callbacks = this.locked.get(key);\n        if (callbacks === undefined || callbacks.length === 0) {\n            this.locked.delete(key);\n            return;\n        }\n        let toCall = callbacks.pop();\n        this.locked.set(key, callbacks);\n        if (toCall !== undefined) {\n            setTimeout(toCall, 0);\n        }\n    }\n}\n\nexport default function getLock(): ProcessLocking {\n    return ProcessLocking.getInstance();\n}","import getProcessLock from './processLock';\n\n/**\n * @author: SuperTokens (https://github.com/supertokens)\n * This library was created as a part of a larger project, SuperTokens(https://supertokens.io) - the best session management solution.\n * You can also check out our other projects on https://github.com/supertokens\n * \n * To contribute to this package visit https://github.com/supertokens/browser-tabs-lock\n * If you face any problems you can file an issue on https://github.com/supertokens/browser-tabs-lock/issues\n * \n * If you have any questions or if you just want to say hi visit https://supertokens.io/discord\n */\n\n\n/**\n * @constant\n * @type {string}\n * @default\n * @description All the locks taken by this package will have this as prefix\n*/\nconst LOCK_STORAGE_KEY = 'browser-tabs-lock-key';\n\ndeclare let setTimeout: any;\ndeclare let window: any;\ndeclare let clearTimeout: any;\n\nexport type StorageHandler = {\n    key: (index: number) => Promise<string | null>;\n    getItem: (key: string) => Promise<string | null>;\n    clear: () => Promise<void>;\n    removeItem: (key: string) => Promise<void>;\n    setItem: (key: string, value: string) => Promise<void>;\n    /**\n     * Sync versions of the storage functions\n     */\n    keySync: (index: number) => string | null;\n    getItemSync: (key: string) => string | null;\n    clearSync: () => void;\n    removeItemSync: (key: string) => void;\n    setItemSync: (key: string, value: string) => void;\n};\n\nconst DEFAULT_STORAGE_HANDLER: StorageHandler = {\n    key: async (index: number) => {\n        throw new Error(\"Unsupported\");\n    },\n    getItem: async (key: string) => {\n        throw new Error(\"Unsupported\");\n    },\n    clear: async () => {\n        return window.localStorage.clear();\n    },\n    removeItem: async (key: string) => {\n        throw new Error(\"Unsupported\");\n    },\n    setItem: async (key: string, value: string) => {\n        throw new Error(\"Unsupported\");\n    },\n    keySync: (index: number) => {\n        return window.localStorage.key(index);\n    },\n    getItemSync: (key: string) => {\n        return window.localStorage.getItem(key);\n    },\n    clearSync: () => {\n        return window.localStorage.clear();\n    },\n    removeItemSync: (key: string) => {\n        return window.localStorage.removeItem(key);\n    },\n    setItemSync: (key: string, value: string) => {\n        return window.localStorage.setItem(key, value);\n    },\n\n}\n\n/**\n * @function delay\n * @param {number} milliseconds - How long the delay should be in terms of milliseconds\n * @returns {Promise<void>} \n */\nfunction delay(milliseconds: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, milliseconds));\n}\n\n/**\n * @function generateRandomString\n * @params {number} length - How long the random string should be\n * @returns {string}\n * @description returns random string whose length is equal to the length passed as parameter\n */\nfunction generateRandomString(length: number): string {\n    const CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz';\n    let randomstring = '';\n    for (let i = 0; i < length; i++) {\n        const INDEX = Math.floor(Math.random() * CHARS.length);\n        randomstring += CHARS[INDEX];\n    }\n    return randomstring;\n}\n\n/**\n * @function getLockId\n * @returns {string}\n * @description Generates an id which will be unique for the browser tab\n */\nfunction getLockId(): string {\n    return Date.now().toString() + generateRandomString(15)\n}\n\nexport default class SuperTokensLock {\n    private static waiters: Array<any> | undefined = undefined;\n    private id: string;\n    private acquiredIatSet: Set<String> = new Set<String>();\n    private storageHandler: StorageHandler | undefined = undefined;\n\n    constructor(storageHandler?: StorageHandler) {\n        this.id = getLockId();\n        this.acquireLock = this.acquireLock.bind(this);\n        this.releaseLock = this.releaseLock.bind(this);\n        this.releaseLock__private__ = this.releaseLock__private__.bind(this);\n        this.waitForSomethingToChange = this.waitForSomethingToChange.bind(this);\n        this.refreshLockWhileAcquired = this.refreshLockWhileAcquired.bind(this);\n        this.storageHandler = storageHandler;\n        if (SuperTokensLock.waiters === undefined) {\n            SuperTokensLock.waiters = [];\n        }\n    }\n\n    /**\n     * @async\n     * @memberOf Lock\n     * @function acquireLock\n     * @param {string} lockKey - Key for which the lock is being acquired\n     * @param {number} [timeout=5000] - Maximum time for which the function will wait to acquire the lock\n     * @returns {Promise<boolean>}\n     * @description Will return true if lock is being acquired, else false.\n     *              Also the lock can be acquired for maximum 10 secs\n     */\n    async acquireLock(lockKey: string, timeout: number = 5000) {\n        let iat = Date.now() + generateRandomString(4);\n        const MAX_TIME = Date.now() + timeout;\n        const STORAGE_KEY = `${LOCK_STORAGE_KEY}-${lockKey}`;\n        const STORAGE: StorageHandler = this.storageHandler === undefined ? DEFAULT_STORAGE_HANDLER : this.storageHandler;\n        while (Date.now() < MAX_TIME) {\n            await delay(30);\n            let lockObj = STORAGE.getItemSync(STORAGE_KEY);\n            if (lockObj === null) {\n                const TIMEOUT_KEY = `${this.id}-${lockKey}-${iat}`;\n                // there is a problem if setItem happens at the exact same time for 2 different processes.. so we add some random delay here.\n                await delay(Math.floor(Math.random() * 25));\n                STORAGE.setItemSync(STORAGE_KEY, JSON.stringify({\n                    id: this.id,\n                    iat,\n                    timeoutKey: TIMEOUT_KEY,\n                    timeAcquired: Date.now(),\n                    timeRefreshed: Date.now()\n                }));\n                await delay(30);    // this is to prevent race conditions. This time must be more than the time it takes for storage.setItem\n                let lockObjPostDelay = STORAGE.getItemSync(STORAGE_KEY);\n                if (lockObjPostDelay !== null) {\n                    let parsedLockObjPostDelay = JSON.parse(lockObjPostDelay);\n                    if (parsedLockObjPostDelay.id === this.id && parsedLockObjPostDelay.iat === iat) {\n                        this.acquiredIatSet.add(iat);\n                        this.refreshLockWhileAcquired(STORAGE_KEY, iat);\n                        return true;\n                    }\n                }\n            } else {\n                SuperTokensLock.lockCorrector(this.storageHandler === undefined ? DEFAULT_STORAGE_HANDLER : this.storageHandler);\n                await this.waitForSomethingToChange(MAX_TIME);\n\n            }\n            iat = Date.now() + generateRandomString(4);\n        }\n        return false;\n    }\n\n    private async refreshLockWhileAcquired(storageKey: string, iat: string) {\n        setTimeout(async () => {\n            await getProcessLock().lock(iat);\n            if (!this.acquiredIatSet.has(iat)) {\n                getProcessLock().unlock(iat);\n                return;\n            }\n            const STORAGE: StorageHandler = this.storageHandler === undefined ? DEFAULT_STORAGE_HANDLER : this.storageHandler;\n            let lockObj = STORAGE.getItemSync(storageKey);\n            if (lockObj !== null) {\n                let parsedLockObj = JSON.parse(lockObj);\n                parsedLockObj.timeRefreshed = Date.now();\n                STORAGE.setItemSync(storageKey, JSON.stringify(parsedLockObj));\n                getProcessLock().unlock(iat);\n            } else {\n                getProcessLock().unlock(iat);\n                return;\n            }\n            this.refreshLockWhileAcquired(storageKey, iat);\n        }, 1000);\n    }\n\n    private async waitForSomethingToChange(MAX_TIME: number) {\n        await new Promise(resolve => {\n            let resolvedCalled = false;\n            let startedAt = Date.now();\n            const MIN_TIME_TO_WAIT = 50;    // ms\n            let removedListeners = false;\n            function stopWaiting() {\n                if (!removedListeners) {\n                    window.removeEventListener('storage', stopWaiting);\n                    SuperTokensLock.removeFromWaiting(stopWaiting);\n                    clearTimeout(timeOutId);\n                    removedListeners = true;\n                }\n                if (!resolvedCalled) {\n                    resolvedCalled = true;\n                    let timeToWait = MIN_TIME_TO_WAIT - (Date.now() - startedAt);\n                    if (timeToWait > 0) {\n                        setTimeout(resolve, timeToWait);\n                    } else {\n                        resolve(null);\n                    }\n                }\n            }\n            window.addEventListener('storage', stopWaiting);\n            SuperTokensLock.addToWaiting(stopWaiting);\n            let timeOutId = setTimeout(stopWaiting, Math.max(0, MAX_TIME - Date.now()));\n        });\n    }\n\n    private static addToWaiting(func: any) {\n        this.removeFromWaiting(func);\n        if (SuperTokensLock.waiters === undefined) {\n            return;\n        }\n        SuperTokensLock.waiters.push(func);\n    }\n\n    private static removeFromWaiting(func: any) {\n        if (SuperTokensLock.waiters === undefined) {\n            return;\n        }\n        SuperTokensLock.waiters = SuperTokensLock.waiters.filter(i => i !== func);\n    }\n\n    private static notifyWaiters() {\n        if (SuperTokensLock.waiters === undefined) {\n            return;\n        }\n        let waiters = [...SuperTokensLock.waiters];    // so that if Lock.waiters is changed it's ok.\n        waiters.forEach(i => i());\n    }\n\n    /**\n     * @function releaseLock\n     * @memberOf Lock\n     * @param {string} lockKey - Key for which lock is being released\n     * @returns {void}\n     * @description Release a lock.\n     */\n    async releaseLock(lockKey: string) {\n        return await this.releaseLock__private__(lockKey);\n    }\n\n    /**\n     * @function releaseLock\n     * @memberOf Lock\n     * @param {string} lockKey - Key for which lock is being released\n     * @returns {void}\n     * @description Release a lock.\n     */\n    private async releaseLock__private__(lockKey: string) {\n        const STORAGE: StorageHandler = this.storageHandler === undefined ? DEFAULT_STORAGE_HANDLER : this.storageHandler;\n        const STORAGE_KEY = `${LOCK_STORAGE_KEY}-${lockKey}`;\n        let lockObj = STORAGE.getItemSync(STORAGE_KEY);\n        if (lockObj === null) {\n            return;\n        }\n        let parsedlockObj = JSON.parse(lockObj);\n        if (parsedlockObj.id === this.id) {\n            await getProcessLock().lock(parsedlockObj.iat);\n\n            this.acquiredIatSet.delete(parsedlockObj.iat);\n            STORAGE.removeItemSync(STORAGE_KEY);\n\n            getProcessLock().unlock(parsedlockObj.iat);\n\n            SuperTokensLock.notifyWaiters();\n        }\n    }\n\n    /**\n     * @function lockCorrector\n     * @returns {void}\n     * @description If a lock is acquired by a tab and the tab is closed before the lock is\n     *              released, this function will release those locks\n     */\n    private static lockCorrector(storageHandler: StorageHandler) {\n        const MIN_ALLOWED_TIME = Date.now() - 5000;\n        const STORAGE = storageHandler;\n        const KEYS: string[] = [];\n        let currIndex = 0;\n        while (true) {\n            let key = STORAGE.keySync(currIndex);\n            if (key === null) {\n                break;\n            }\n            KEYS.push(key);\n            currIndex++;\n        }\n        let notifyWaiters = false;\n        for (let i = 0; i < KEYS.length; i++) {\n            const LOCK_KEY = KEYS[i];\n            if (LOCK_KEY.includes(LOCK_STORAGE_KEY)) {\n                let lockObj = STORAGE.getItemSync(LOCK_KEY);\n                if (lockObj !== null) {\n                    let parsedlockObj = JSON.parse(lockObj);\n                    if ((parsedlockObj.timeRefreshed === undefined && parsedlockObj.timeAcquired < MIN_ALLOWED_TIME) ||\n                        (parsedlockObj.timeRefreshed !== undefined && parsedlockObj.timeRefreshed < MIN_ALLOWED_TIME)) {\n                        STORAGE.removeItemSync(LOCK_KEY);\n                        notifyWaiters = true;\n                    }\n                }\n            }\n        }\n        if (notifyWaiters) {\n            SuperTokensLock.notifyWaiters();\n        }\n    }\n}\n","import Lock from \"../vendor/browser-tabs-lock\";\n\nconst DEFAULT_LOCK_TIMEOUT_MS = 10_000;\n\nexport function withLock<T>(\n  lockName: string,\n  callback: () => T | Promise<T>,\n  { timeout = DEFAULT_LOCK_TIMEOUT_MS } = {},\n): Promise<T> {\n  if (!lockName) {\n    throw new TypeError(\"lockName is required and must be a non-empty string.\");\n  }\n\n  return \"locks\" in navigator\n    ? withNativeLock(lockName, callback, timeout)\n    : withVendorLock(lockName, callback, timeout);\n}\n\nasync function withNativeLock<T>(\n  lockName: string,\n  callback: () => T | Promise<T>,\n  timeout: number,\n) {\n  try {\n    return await navigator.locks.request(\n      lockName,\n      { signal: AbortSignal.timeout(timeout) },\n      callback,\n    );\n  } catch (error) {\n    if (error instanceof DOMException) {\n      switch (error.name) {\n        case \"AbortError\":\n          throw new LockError(\"AcquisitionTimeoutError\", lockName, \"Native\");\n\n        case \"InvalidStateError\":\n        case \"NotSupportedError\":\n        case \"SecurityError\":\n        // These are documented but we currently don't handle them\n        // in any particular way and let them bubble up.\n      }\n    }\n\n    throw error;\n  }\n}\n\nasync function withVendorLock<T>(\n  lockName: string,\n  callback: () => T | Promise<T>,\n  timeout: number,\n) {\n  const lock = new Lock();\n\n  try {\n    if (await lock.acquireLock(lockName, timeout)) {\n      return await callback();\n    } else {\n      throw new LockError(\"AcquisitionTimeoutError\", lockName, \"Vendor\");\n    }\n  } finally {\n    await lock.releaseLock(lockName);\n  }\n}\n\nexport class LockError extends Error {\n  constructor(\n    override readonly name: \"AcquisitionTimeoutError\",\n    readonly lockName: string,\n    type: \"Native\" | \"Vendor\",\n  ) {\n    super(`Lock acquisition timed out for \"${lockName}\" (${type})`);\n  }\n}\n","import { User, UserRaw } from \"../interfaces\";\n\nexport const deserializeUser = (user: UserRaw): User => ({\n  object: user.object,\n  id: user.id,\n  email: user.email,\n  emailVerified: user.email_verified,\n  firstName: user.first_name,\n  profilePictureUrl: user.profile_picture_url,\n  lastName: user.last_name,\n  lastSignInAt: user.last_sign_in_at,\n  externalId: user.external_id,\n  createdAt: user.created_at,\n  updatedAt: user.updated_at,\n});\n","import {\n  AuthenticationResponse,\n  AuthenticationResponseRaw,\n} from \"../interfaces\";\nimport { deserializeUser } from \"./user.serializer\";\n\nexport const deserializeAuthenticationResponse = (\n  authenticationResponse: AuthenticationResponseRaw,\n): AuthenticationResponse => {\n  const {\n    user,\n    organization_id,\n    access_token,\n    refresh_token,\n    impersonator,\n    ...rest\n  } = authenticationResponse;\n\n  return {\n    user: deserializeUser(user),\n    organizationId: organization_id,\n    accessToken: access_token,\n    refreshToken: refresh_token,\n    impersonator,\n    ...rest,\n  };\n};\n","import { CodeExchangeError, RefreshError } from \"./errors\";\nimport {\n  AuthenticationResponseRaw,\n  GetAuthorizationUrlOptions,\n} from \"./interfaces\";\nimport { deserializeAuthenticationResponse } from \"./serializers\";\nimport { toQueryString } from \"./utils\";\n\nconst DEFAULT_HOSTNAME = \"api.workos.com\";\n\nexport class HttpClient {\n  readonly #baseUrl: string;\n  readonly #clientId: string;\n\n  constructor({\n    clientId,\n    hostname = DEFAULT_HOSTNAME,\n    port,\n    https = true,\n  }: {\n    clientId: string;\n    hostname?: string;\n    port?: number;\n    https?: boolean;\n  }) {\n    this.#baseUrl = `${https ? \"https\" : \"http\"}://${hostname}${\n      port ? `:${port}` : \"\"\n    }`;\n    this.#clientId = clientId;\n  }\n\n  async authenticateWithRefreshToken({\n    refreshToken,\n    organizationId,\n    useCookie,\n  }: {\n    refreshToken: string | undefined;\n    organizationId?: string;\n    useCookie: boolean;\n  }) {\n    const response = await this.#post(\"/user_management/authenticate\", {\n      useCookie,\n      body: {\n        client_id: this.#clientId,\n        grant_type: \"refresh_token\",\n        ...(!useCookie && { refresh_token: refreshToken }),\n        organization_id: organizationId,\n      },\n    });\n\n    if (response.ok) {\n      const data = (await response.json()) as AuthenticationResponseRaw;\n      return deserializeAuthenticationResponse(data);\n    } else {\n      const error = (await response.json()) as any;\n      throw new RefreshError(error.error_description);\n    }\n  }\n\n  async authenticateWithCode({\n    code,\n    codeVerifier,\n    useCookie,\n  }: {\n    code: string;\n    codeVerifier: string;\n    useCookie: boolean;\n  }) {\n    const response = await this.#post(\"/user_management/authenticate\", {\n      useCookie,\n      body: {\n        code,\n        client_id: this.#clientId,\n        grant_type: \"authorization_code\",\n        code_verifier: codeVerifier,\n      },\n    });\n\n    if (response.ok) {\n      const data = (await response.json()) as AuthenticationResponseRaw;\n      return deserializeAuthenticationResponse(data);\n    }\n\n    const error = await response.json();\n    throw new CodeExchangeError(error.error_description);\n  }\n\n  #post(\n    path: \"/user_management/authenticate\",\n    { body, useCookie }: { body: Record<string, unknown>; useCookie: boolean },\n  ) {\n    return fetch(new URL(path, this.#baseUrl), {\n      method: \"POST\",\n      ...(useCookie && { credentials: \"include\" }),\n      headers: {\n        Accept: \"application/json, text/plain, */*\",\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(body),\n    });\n  }\n\n  getAuthorizationUrl({\n    connectionId,\n    context,\n    domainHint,\n    loginHint,\n    organizationId,\n    provider = \"authkit\",\n    redirectUri,\n    state,\n    screenHint,\n    passwordResetToken,\n    invitationToken,\n    codeChallenge,\n    codeChallengeMethod,\n  }: GetAuthorizationUrlOptions) {\n    if (!provider && !connectionId && !organizationId) {\n      throw new TypeError(\n        `Incomplete arguments. Need to specify either a 'connectionId', 'organizationId', or 'provider'.`,\n      );\n    }\n\n    if (provider !== \"authkit\" && screenHint) {\n      throw new TypeError(\n        `'screenHint' is only supported for 'authkit' provider`,\n      );\n    }\n\n    if (context) {\n      console.warn(\n        `\\`context\\` is deprecated. We previously required initiate login endpoints to return the\n\\`context\\` query parameter when getting the authorization URL. This is no longer necessary.`,\n      );\n    }\n\n    const query = toQueryString({\n      connection_id: connectionId,\n      organization_id: organizationId,\n      domain_hint: domainHint,\n      login_hint: loginHint,\n      provider,\n      client_id: this.#clientId,\n      redirect_uri: redirectUri,\n      response_type: \"code\",\n      state,\n      screen_hint: screenHint,\n      invitation_token: invitationToken,\n      password_reset_token: passwordResetToken,\n      code_challenge: codeChallenge,\n      code_challenge_method: codeChallengeMethod,\n    });\n\n    return `${this.#baseUrl}/user_management/authorize?${query}`;\n  }\n\n  getLogoutUrl({\n    sessionId,\n    returnTo,\n  }: {\n    sessionId: string;\n    returnTo: string | undefined;\n  }) {\n    const url = new URL(\"/user_management/sessions/logout\", this.#baseUrl);\n\n    url.searchParams.set(\"session_id\", sessionId);\n    if (returnTo) {\n      url.searchParams.set(\"return_to\", returnTo);\n    }\n\n    return url;\n  }\n}\n","import {\n  AuthenticationResponse,\n  CreateClientOptions,\n  OnRefreshResponse,\n  User,\n} from \"./interfaces\";\nimport { NoClientIdProvidedException } from \"./exceptions\";\nimport {\n  isRedirectCallback,\n  memoryStorage,\n  createPkceChallenge,\n  setSessionData,\n  removeSessionData,\n  storageKeys,\n} from \"./utils\";\nimport { getRefreshToken, getClaims } from \"./utils/session-data\";\nimport { RedirectParams } from \"./interfaces/create-client-options.interface\";\nimport { LoginRequiredError, RefreshError } from \"./errors\";\nimport { withLock, LockError } from \"./utils/locking\";\nimport { HttpClient } from \"./http-client\";\n\ninterface RedirectOptions {\n  /**\n   *  @deprecated We previously required initiate login endpoints to return the `context`\n   *  query parameter when getting the authorization URL. This is no longer necessary.\n   */\n  context?: string;\n  invitationToken?: string;\n  loginHint?: string;\n  organizationId?: string;\n  passwordResetToken?: string;\n  state?: any;\n  type: \"sign-in\" | \"sign-up\";\n}\n\ntype State =\n  | { tag: \"INITIAL\" }\n  | { tag: \"AUTHENTICATING\"; response: Promise<AuthenticationResponse> }\n  | { tag: \"AUTHENTICATED\" }\n  | { tag: \"ERROR\" };\n\nexport const ORGANIZATION_ID_SESSION_STORAGE_KEY = \"workos_organization_id\";\n\nconst REFRESH_LOCK_NAME = \"WORKOS_REFRESH_SESSION\";\n\nexport class Client {\n  #state: State;\n  #refreshTimer: ReturnType<typeof setTimeout> | undefined;\n\n  readonly #httpClient: HttpClient;\n  readonly #redirectUri: string;\n  readonly #devMode: boolean;\n  readonly #onBeforeAutoRefresh: () => boolean;\n  readonly #onRedirectCallback: (params: RedirectParams) => void;\n  readonly #onRefreshCallback:\n    | ((response: OnRefreshResponse) => void)\n    | undefined;\n  readonly #onRefreshFailure:\n    | ((params: { signIn: () => Promise<void> }) => void)\n    | undefined;\n  readonly #refreshBufferInterval: number;\n\n  constructor(\n    clientId: string,\n    {\n      apiHostname: hostname,\n      https,\n      port,\n      redirectUri = window.origin,\n      devMode = location.hostname === \"localhost\" ||\n        location.hostname === \"127.0.0.1\",\n      // refresh if this is true\n      onBeforeAutoRefresh = () => {\n        return !document.hidden;\n      },\n      onRedirectCallback = (_: RedirectParams) => {},\n      onRefresh,\n      onRefreshFailure,\n      refreshBufferInterval = 10,\n    }: CreateClientOptions = {},\n  ) {\n    if (!clientId) {\n      throw new NoClientIdProvidedException();\n    }\n\n    this.#httpClient = new HttpClient({ clientId, hostname, port, https });\n    this.#devMode = devMode;\n    this.#redirectUri = redirectUri;\n    this.#state = { tag: \"INITIAL\" };\n    this.#onBeforeAutoRefresh = onBeforeAutoRefresh;\n    this.#onRedirectCallback = onRedirectCallback;\n    this.#onRefreshCallback = onRefresh;\n    this.#onRefreshFailure = onRefreshFailure;\n    this.#refreshBufferInterval = refreshBufferInterval;\n  }\n\n  async initialize() {\n    if (this.#state.tag !== \"INITIAL\") {\n      return;\n    }\n\n    const searchParams = new URLSearchParams(window.location.search);\n    if (isRedirectCallback(this.#redirectUri, searchParams)) {\n      await this.#handleCallback();\n    } else if (\n      document.cookie.includes(\"workos-has-session=\") ||\n      getRefreshToken({ devMode: this.#devMode })\n    ) {\n      try {\n        await this.#refreshSession();\n        this.#scheduleAutomaticRefresh();\n      } catch {\n        // this is expected to fail if a user doesn't\n        // have a session. do nothing.\n      }\n    }\n  }\n\n  async getSignInUrl(opts: Omit<RedirectOptions, \"type\"> = {}) {\n    const url = await this.#getAuthorizationUrl({ ...opts, type: \"sign-in\" });\n    return url;\n  }\n\n  async getSignUpUrl(opts: Omit<RedirectOptions, \"type\"> = {}) {\n    const url = await this.#getAuthorizationUrl({ ...opts, type: \"sign-up\" });\n    return url;\n  }\n\n  async signIn(opts: Omit<RedirectOptions, \"type\"> = {}) {\n    const url = await this.#getAuthorizationUrl({ ...opts, type: \"sign-in\" });\n    window.location.assign(url);\n  }\n\n  async signUp(opts: Omit<RedirectOptions, \"type\"> = {}) {\n    const url = await this.#getAuthorizationUrl({ ...opts, type: \"sign-up\" });\n    window.location.assign(url);\n  }\n\n  signOut(options?: { returnTo?: string; navigate?: true }): void;\n  signOut(options?: { returnTo?: string; navigate: false }): Promise<void>;\n  signOut(\n    options: { returnTo?: string; navigate?: boolean } = { navigate: true },\n  ): void | Promise<void> {\n    const navigate = options.navigate ?? true;\n    const accessToken = memoryStorage.getItem(storageKeys.accessToken);\n    if (typeof accessToken !== \"string\") return;\n    const { sid: sessionId } = getClaims(accessToken);\n\n    const url = this.#httpClient.getLogoutUrl({\n      sessionId,\n      returnTo: options?.returnTo,\n    });\n\n    if (url) {\n      removeSessionData({ devMode: this.#devMode });\n\n      if (navigate) {\n        window.location.assign(url);\n      } else {\n        return new Promise(async (resolve) => {\n          fetch(url, {\n            mode: \"no-cors\",\n            credentials: \"include\",\n          })\n            .catch((error) => {\n              console.warn(\"AuthKit: Failed to send logout request\", error);\n            })\n            .finally(resolve);\n        });\n      }\n    }\n  }\n\n  async getAccessToken(options?: { forceRefresh?: boolean }): Promise<string> {\n    if (options?.forceRefresh || this.#shouldRefresh()) {\n      try {\n        await this.#refreshSession();\n      } catch (err) {\n        if (err instanceof RefreshError) {\n          throw new LoginRequiredError();\n        } else {\n          throw err;\n        }\n      }\n    }\n\n    const accessToken = this.#getAccessToken();\n    if (!accessToken) {\n      throw new LoginRequiredError();\n    }\n\n    return accessToken;\n  }\n\n  getUser() {\n    const user = memoryStorage.getItem(storageKeys.user);\n    return user ? (user as User) : null;\n  }\n\n  dispose() {\n    clearTimeout(this.#refreshTimer);\n    memoryStorage.reset();\n  }\n\n  async #handleCallback() {\n    if (this.#state.tag !== \"INITIAL\") {\n      return;\n    }\n\n    const url = new URL(window.location.href);\n    const code = url.searchParams.get(\"code\");\n    const stateParam = url.searchParams.get(\"state\");\n    const state = stateParam ? JSON.parse(stateParam) : undefined;\n\n    // grab the previously stored code verifier from session storage\n    const codeVerifier = window.sessionStorage.getItem(\n      storageKeys.codeVerifier,\n    );\n\n    if (code) {\n      if (codeVerifier) {\n        try {\n          this.#state = {\n            tag: \"AUTHENTICATING\",\n            response: this.#httpClient.authenticateWithCode({\n              code,\n              codeVerifier,\n              useCookie: this.#useCookie,\n            }),\n          };\n          const authenticationResponse = await this.#state.response;\n\n          if (authenticationResponse) {\n            this.#state = { tag: \"AUTHENTICATED\" };\n            this.#scheduleAutomaticRefresh();\n            setSessionData(authenticationResponse, { devMode: this.#devMode });\n            this.#onRefresh(authenticationResponse);\n            this.#onRedirectCallback({ state, ...authenticationResponse });\n          }\n        } catch (error) {\n          this.#state = { tag: \"ERROR\" };\n          console.error(error);\n        }\n      } else {\n        this.#state = { tag: \"ERROR\" };\n        console.error(`Couldn't exchange code.\n\nAn authorization_code was supplied for a login which did not originate at the application. This could happen for various reasons:\n\n* This could have been an attempted Login CSRF attack. You were not affected.\n* The developer may not have configured a Login Initiation endpoint.`);\n      }\n    }\n\n    // Remove code from search params\n    const cleanUrl = new URL(window.location.toString());\n    cleanUrl.search = \"\";\n    window.sessionStorage.removeItem(storageKeys.codeVerifier);\n    window.history.replaceState({}, \"\", cleanUrl);\n  }\n\n  async #scheduleAutomaticRefresh() {\n    this.#refreshTimer = setTimeout(() => {\n      if (this.#shouldRefresh() && this.#onBeforeAutoRefresh()) {\n        this.#refreshSession()\n          .catch((e) => {\n            console.debug(e);\n          })\n          .finally(() => this.#scheduleAutomaticRefresh());\n      } else {\n        this.#scheduleAutomaticRefresh();\n      }\n    }, 1000);\n  }\n\n  /**\n   * Switches to the requested organization.\n   *\n   * Redirects to the hosted login page for the given organization if the\n   * switch is unsuccessful.\n   */\n  async switchToOrganization({\n    organizationId,\n    signInOpts = {},\n  }: {\n    organizationId: string;\n    signInOpts?: Omit<RedirectOptions, \"type\" | \"organizationId\">;\n  }) {\n    try {\n      await this.#refreshSession({ organizationId });\n    } catch (error) {\n      if (error instanceof RefreshError) {\n        this.signIn({ ...signInOpts, organizationId });\n      } else {\n        throw error;\n      }\n    }\n  }\n\n  async #refreshSession({ organizationId }: { organizationId?: string } = {}) {\n    if (this.#state.tag === \"AUTHENTICATING\") {\n      await this.#state.response;\n      return;\n    }\n\n    const beginningState = this.#state;\n\n    this.#state = {\n      tag: \"AUTHENTICATING\",\n      response: this.#doRefresh({ organizationId, beginningState }),\n    };\n\n    await this.#state.response;\n  }\n\n  async #doRefresh({\n    organizationId,\n    beginningState,\n  }: {\n    organizationId?: string;\n    beginningState: State;\n  }): Promise<AuthenticationResponse> {\n    try {\n      return await withLock(REFRESH_LOCK_NAME, async () => {\n        if (organizationId) {\n          sessionStorage.setItem(\n            ORGANIZATION_ID_SESSION_STORAGE_KEY,\n            organizationId,\n          );\n        } else {\n          const accessToken = this.#getAccessToken();\n          if (accessToken) {\n            organizationId = getClaims(accessToken)?.org_id;\n          } else {\n            organizationId =\n              sessionStorage.getItem(ORGANIZATION_ID_SESSION_STORAGE_KEY) ??\n              undefined;\n          }\n        }\n\n        const authenticationResponse =\n          await this.#httpClient.authenticateWithRefreshToken({\n            refreshToken: getRefreshToken({ devMode: this.#devMode }),\n            organizationId,\n            useCookie: this.#useCookie,\n          });\n\n        this.#state = { tag: \"AUTHENTICATED\" };\n        setSessionData(authenticationResponse, { devMode: this.#devMode });\n        this.#onRefresh(authenticationResponse);\n        return authenticationResponse;\n      });\n    } catch (error) {\n      if (\n        error instanceof LockError &&\n        error.name === \"AcquisitionTimeoutError\"\n      ) {\n        console.warn(\"Couldn't acquire refresh lock.\");\n\n        // preserving the original state so that we can try again next time\n        this.#state = beginningState;\n        throw error;\n      }\n\n      if (beginningState.tag !== \"INITIAL\") {\n        console.debug(error);\n      }\n\n      if (error instanceof RefreshError) {\n        removeSessionData({ devMode: this.#devMode });\n        // fire the refresh failure UNLESS this is the initial refresh attempt\n        // (the initial refresh is expected to fail if a user has not logged in\n        // ever or recently)\n        beginningState.tag !== \"INITIAL\" &&\n          this.#onRefreshFailure &&\n          this.#onRefreshFailure({ signIn: this.signIn.bind(this) });\n\n        this.#state = { tag: \"ERROR\" };\n      } else {\n        // transitioning into the AUTHENTICATED state ensures that we will\n        // attempt to refresh the token on future getAccessToken calls()\n        //\n        // this could maybe be a new state for clarity? TEMPORARY_ERROR?\n        this.#state = { tag: \"AUTHENTICATED\" };\n      }\n\n      throw error;\n    }\n  }\n\n  #shouldRefresh() {\n    switch (this.#state.tag) {\n      case \"INITIAL\":\n      case \"AUTHENTICATING\":\n        return true;\n      case \"ERROR\":\n        return false;\n      case \"AUTHENTICATED\":\n        const accessToken = memoryStorage.getItem(storageKeys.accessToken) as\n          | string\n          | undefined;\n        const expiresAt = memoryStorage.getItem(storageKeys.expiresAt) as\n          | number\n          | undefined;\n\n        if (!accessToken || !expiresAt) {\n          return true;\n        }\n\n        const tokenRefreshBufferInSeconds = this.#refreshBufferInterval * 1000;\n        const refreshTime = expiresAt - tokenRefreshBufferInSeconds;\n        return refreshTime < Date.now();\n    }\n  }\n\n  async #getAuthorizationUrl({\n    context,\n    invitationToken,\n    loginHint,\n    organizationId,\n    passwordResetToken,\n    state,\n    type,\n  }: RedirectOptions) {\n    const { codeVerifier, codeChallenge } = await createPkceChallenge();\n    // store the code verifier in session storage for later use (after the redirect back from authkit)\n    window.sessionStorage.setItem(storageKeys.codeVerifier, codeVerifier);\n    const url = this.#httpClient.getAuthorizationUrl({\n      codeChallenge,\n      codeChallengeMethod: \"S256\",\n      context,\n      invitationToken,\n      loginHint,\n      organizationId,\n      passwordResetToken,\n      redirectUri: this.#redirectUri,\n      screenHint: type,\n      state: state ? JSON.stringify(state) : undefined,\n    });\n\n    return url;\n  }\n\n  #getAccessToken() {\n    return memoryStorage.getItem(storageKeys.accessToken) as string | undefined;\n  }\n\n  get #useCookie() {\n    return !this.#devMode;\n  }\n\n  async #onRefresh(authenticationResponse: AuthenticationResponse) {\n    if (this.#onRefreshCallback) {\n      // there's no good reason for client code to access the refresh token\n      const { refreshToken: _refreshToken, ...onRefreshData } =\n        authenticationResponse;\n      this.#onRefreshCallback(onRefreshData);\n    }\n  }\n}\n\nexport async function createClient(\n  clientId: string,\n  options: CreateClientOptions = {},\n) {\n  const client = new Client(clientId, options);\n\n  await client.initialize();\n\n  return client;\n}\n"],"mappings":"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","names":[]}